2013.09.19

スライドを作るためのライブラリを構築する。
QuasiQuotes を使おうと思っている。

タイトル

* タイトル
    説明
* タイトル
    説明

* 項目
    - 項目
    - 項目
* 項目
    - 項目
    - 項目

図

まずはこんな感じという例を作ってみようかな。

乱立した純粋関数型言語を標準化したもの。
	|
	V
関数型言語の研究の成果が凝集している。

2013.09.20 Fri.

今は、
第一級関数
参照透過(明)
静的型付
遅延評価

をポイントとしているが、それ以外に必要な機能としては、
パターンマッチと型構築も必要となる。

関数の部分適用については後にする。

2013.09.23 Mon.

「何ができるか」「何が得られるか」を追加しよう。
まずは、C言語でできることなら何でもできる。
なぜなら、FFI (Foreign Function Interface) によって C の関数が使えるから。
実用的な言語である。

しかし、もしも Haskell を使わなかったとしても、
「考え方」を学ぶことで、他の言語でも「良い習慣」が身につくことになる。
「良い習慣」とは、状態変化を最小限にするということ。
最近のプログラミングの世界で重要性を増している
「並列(parallel)」「並行(concurrent)」処理の際にも役に立つ。

2013.09.28 Sat.

Haskellの本当の本当のプリミティブは

data ... = ...
var = ...
\par -> ...
case ... of ...
fun arg1 arg2 ...

の5つなのかもしれないな。

2013.10.01 Tue.

再帰的定義で触れなければならないのは
反復的定義
それと ones = 1 : ones のような形

反復的定義の話は正格評価の話をしなければならないので、
後でもう一度触れることにしよう。

2013.10.02 Wed.

IO monadの話のなかで、do記法に触れる必要があるな。
そしたら例題->演習といった感じか。

遅延IOの話はiterateeを紹介するときでいいだろう。

第1回 ミニマルな本質
第2回 特徴
第3回 最小限の意味論と構文糖
第4回 リスト
第5回 再帰関数
第6回 IO monad
(ここまで作った、以下予定)
第7回 型クラス
第8回 moduleシステム
第9回 落ち穂拾い
---
第10回 monad
第11回 type families
第12回 monad transfer library
第13回 array, bytestring
第14回 Map (Hashにもちょっと触れる)
第15回 GADTs
第16回 ffi
---
第17回 functor, applicative, monad
第18回 free monad
第19回 operational monad
第20回 template haskell
第21回 QuasiQuotes
第22回 parser (papillon の紹介)
第23回 unsafePerformIO, unsafeInterleaveIO
第24回 遅延IOとiteratee
第25回 Arrow
第26回 Sequence (finger tree, queue)

どこかで queue にも触れたいな
finger tree面白いな

どこかで _ と if ... then ... else と guard について触れる必要があるな
あとは let ... in ..., where ...,
type と newtype もどこかで触れなければならないな。
Int と Integer について、も。

2013.10.03

IO monad を

type IO a = World -> (a, World)
として説明するやりかたに違和感を感じるのだが。
ひとつひとつの説明は確かに合っているような気はするが。

置き換えということを考える。
Worldはすべて異なると考える。

putStrLn "Hello, world!" :: World -> ((), World)

putStrLn "Hello, world!" world0 :: ((), World)

getLine :: World -> (Char, World)
getLine world0 :: (Char, World)

評価 -- 動作
