2013.09.19

スライドを作るためのライブラリを構築する。
QuasiQuotes を使おうと思っている。

タイトル

* タイトル
    説明
* タイトル
    説明

* 項目
    - 項目
    - 項目
* 項目
    - 項目
    - 項目

図

まずはこんな感じという例を作ってみようかな。

乱立した純粋関数型言語を標準化したもの。
	|
	V
関数型言語の研究の成果が凝集している。

2013.09.20 Fri.

今は、
第一級関数
参照透過(明)
静的型付
遅延評価

をポイントとしているが、それ以外に必要な機能としては、
パターンマッチと型構築も必要となる。

関数の部分適用については後にする。

2013.09.23 Mon.

「何ができるか」「何が得られるか」を追加しよう。
まずは、C言語でできることなら何でもできる。
なぜなら、FFI (Foreign Function Interface) によって C の関数が使えるから。
実用的な言語である。

しかし、もしも Haskell を使わなかったとしても、
「考え方」を学ぶことで、他の言語でも「良い習慣」が身につくことになる。
「良い習慣」とは、状態変化を最小限にするということ。
最近のプログラミングの世界で重要性を増している
「並列(parallel)」「並行(concurrent)」処理の際にも役に立つ。

2013.09.28 Sat.

Haskellの本当の本当のプリミティブは

data ... = ...
var = ...
\par -> ...
case ... of ...
fun arg1 arg2 ...

の5つなのかもしれないな。

2013.10.01 Tue.

再帰的定義で触れなければならないのは
反復的定義
それと ones = 1 : ones のような形

反復的定義の話は正格評価の話をしなければならないので、
後でもう一度触れることにしよう。

2013.10.02 Wed.

IO monadの話のなかで、do記法に触れる必要があるな。
そしたら例題->演習といった感じか。

遅延IOの話はiterateeを紹介するときでいいだろう。

第1回 ミニマルな本質
第2回 特徴
第3回 最小限の意味論と構文糖
第4回 リスト
第5回 再帰関数
第6回 IO monad
第7回 型クラス (newtypeの話題もここに入れよう)
第8回 moduleシステム
第9回 落ち穂拾い
第10回 ghcの使いかた (runghc, ghciやその他のオプションについて)
---
(ここまで作った、以下予定)
第11回 ドキュメンテーション(haddock)
第12回 テスト(型によるチェック、展開による証明、doctest, quickcheck, hunit)
第13回 monad
第14回 type families
第15回 monad transfer library
第16回 GADTs
第17回 プロファイリング
第18回 正格評価(foldl'あたりから入ると良さそうだ)
第19回 パターンマッチと正格評価(遅延パターン、bang pattern等)
第20回 array, bytestring
第21回 Map (Hashにもちょっと触れる)
第22回 zipper
第23回 例外処理
第24回 ffi
第25回 unbox型
第26回 cabalの使いかた(テストの自動化も含めて)
---
第27回 functor, applicative, monad
第28回 free monad
第29回 operational monad
第30回 並行実行
第31回 forall
第32回 ST monad
第33回 ref, mvar, chan, tvar
第34回 stm
第35回 正格評価、非正格評価、正規形、頭部正規形、弱頭部正規形
第35回 deepseq
第36回 並列実行
第37回 template haskell
第38回 QuasiQuotes
第39回 parser (papillon の紹介)
第40回 unsafePerformIO, unsafeInterleaveIO
第41回 遅延IOとiteratee
第42回 可変長引数 (Text.Printf等)
第43回 Arrow
第44回 Foldable
第45回 Traversable
第46回 Sequence (finger tree, queue)
第47回 モナド内包表記 monad comprehension

どこかで queue にも触れたいな
finger tree面白いな

Preludeについても触れておく必要があるな
あとは let ... in ..., where ...,
newtype もどこかで触れなければならないな。
Int と Integer について、も。
field label についても、か。
pattern guardはHaskell 2010に入ってるので初級編で触れておこうかな。
view patternもついでに
ffiも2010に入ってるな。
-- や {- ... -}コメントについて。
.lhs についてはどうしようかな。
落ち穂拾いのところで簡単に触れておこう。
型注釈についても触れとこう。
それとas patternもだな。
irrefutable patternも。

bang patternについてはどこか別の場所で触れる必要がある。

正格評価についてもどこかで触れる必要があるな。
それとunbox型も、かな。

ST monad や stm についても触れたい。
ST monad について触れるなら forall についても触れる必要があるだろう。
stm について触れる際に ref, mvar, chan, tvar あたりにも触れることにする。

profiling の話もいれる必要があるな。

第7回のキューの例をよりスムーズにするために、
第6回のIOのところでIOに関する再帰的プロセスと反復的プロセスについて
例を挙げておく必要があるだろう。

並列実行について触れるかどうか。
並行実行については触れておきたいな。<- stmより前がいいだろう。
例外処理も必要だな。

zipperについてどこかで触れたいな。
Foldableについても触れたいな。
Traversableについても触れる必要があるかも。
haddockにも触れる必要があるな。

RULESも面白い機能ではある。
INLINEについても見ておく必要がある。

2013.10.03

IO monad を

type IO a = World -> (a, World)
として説明するやりかたに違和感を感じるのだが。
ひとつひとつの説明は確かに合っているような気はするが。

置き換えということを考える。
Worldはすべて異なると考える。

putStrLn "Hello, world!" :: World -> ((), World)

putStrLn "Hello, world!" world0 :: ((), World)

getLine :: World -> (Char, World)
getLine world0 :: (Char, World)

評価 -- 動作

deriving Eq, Ord, Enum, Ix, Bounded, Read, Show

2013.10.05 Sat.

baby -> toddler/infant -> child -> teenager/adolescent -> young adult ->
	adult -> middle-aged person -> senior citizen

2013.10.09 Wed.

class定義におけるデフォルトの定義について触れること。
「落ち穂拾い」で default も扱おうかな。

2013.10.10 Thr.

次はexport/import list に型や型内部の詳細を入れる方法
Some, Some(Some), Some(..)といった形

2013.10.11 Fri.

getSum = (+) <$> getI <+> getSum

getSumIter i = getSumIter . (+ i) <$> getI

2013.10.12 Sat.

遅延パターンまたは不可反駁パターンについて。
また、パターン束縛が遅延パターンになっていることについて。
不可反駁パターンよりも遅延パターンのほうがわかりやすいかも。
いろいろな場所でのパターンマッチではなく、パターン束縛と呼ぼうかな。

2013.10.16 Wed.

hunitの使いかた。

runTestTT
~?
~=?
~?=
~:

title ~: [
	someIO ~? "error message",
	expect ~=? test,
	test ~?= expect
 ]

正規形(normal form):
	完全に簡約済みの形
頭部正規形(head normal form):
	引数部に簡約可能な部分があっても良い
弱頭部正規形(weak head normal form):
	上記に加え、
	ラムダ式の本体部に簡約可能な部分があっても良い

弱頭部正規形はアルファ変換無しでname captureの問題を解決する。
グラフ簡約と相性がいいらしい。

2013.11.28 Thu.

lst1 = ([1, 2, 3] ++ [4, 5, 6]) ++ [7, 8, 9]

lst2 = [1, 2, 3] ++ ([4, 5, 6] ++ [7, 8, 9])

[] ++ ys = ys
(x : xs) ++ ys = x : (xs ++ ys)

(x : _) !! 0 = x
(_ : xs) !! n = xs !! (n - 1)

lst1 !! 7
-> (([1, 2, 3] ++ [4, 5, 6]) ++ [7, 8, 9]) !! 7
-> ((1 : ([2, 3] ++ [4, 5, 6])) ++ [7, 8, 9]) !! 7
-> (1 : (([2, 3] ++ [4, 5, 6]) ++ [7, 8, 9])) !! 7
-> (([2, 3] ++ [4, 5, 6]) ++ [7, 8, 9]) !! 6
-> ((2 : ([3] ++ [4, 5, 6])) ++ [7, 8, 9]) !! 6
-> (2 : (([3] ++ [4, 5, 6]) ++ [7, 8, 9])) !! 6
-> (([3] ++ [4, 5, 6]) ++ [7, 8, 9]) !! 5
-> ((3 : ([] ++ [4, 5, 6])) ++ [7, 8, 9]) !! 5
-> (3 : (([] ++ [4, 5, 6]) ++ [7, 8, 9])) !! 5
-> (([] ++ [4, 5, 6]) ++ [7, 8, 9]) !! 4
-> ([4, 5, 6] ++ [7, 8, 9]) !! 4
-> (4 : ([5, 6] ++ [7, 8, 9])) !! 4
-> ([5, 6] ++ [7, 8, 9]) !! 3
-> (5 : ([6] ++ [7, 8, 9])) !! 3
-> ([6] ++ [7, 8, 9]) !! 2
-> (6 : ([] ++ [7, 8, 9])) !! 2
-> ([] ++ [7, 8, 9]) !! 1
-> [7, 8, 9] !! 1
-> (7 : [8, 9]) !! 1
-> [8, 9] !! 0
-> (8 : [9]) !! 0
-> 8

lst2 !! 7
-> ([1, 2, 3] ++ ([4, 5, 6] ++ [7, 8, 9])) !! 7
-> (1 : ([2, 3] ++ ([4, 5, 6] ++ [7, 8, 9]))) !! 7
-> ([2, 3] ++ ([4, 5, 6] ++ [7, 8, 9])) !! 6
-> (2 : ([3] ++ ([4, 5, 6] ++ [7, 8, 9]))) !! 6
-> ([3] ++ ([4, 5, 6] ++ [7, 8, 9])) !! 5
-> (3 : ([] ++ ([4, 5, 6] ++ [7, 8, 9]))) !! 5
-> ([] ++ ([4, 5, 6] ++ [7, 8, 9])) !! 4
-> ([4, 5, 6] ++ [7, 8, 9]) !! 4
-> (4 : ([5, 6] ++ [7, 8, 9])) !! 4
-> ([5, 6] ++ [7, 8, 9]) !! 3
-> (5 : ([6] ++ [7, 8, 9])) !! 3
-> ([6] ++ [7, 8, 9]) !! 2
-> (6 : ([] ++ [7, 8, 9])) !! 2
-> ([] ++ [7, 8, 9]) !! 1
-> [7, 8, 9] !! 1
-> (7 : [8, 9]) !! 1
-> [8, 9] !! 0
-> (8 : [9]) !! 0
-> 8

([1, 2, 3] ++ [4, 5, 6]) !! 3
-> (1 : ([2, 3] ++ [4, 5, 6])) !! 3
-> ([2, 3] ++ [4, 5, 6]) !! 2
-> (2 : ([3] ++ [4, 5, 6])) !! 2
-> ([3] ++ [4, 5, 6]) !! 1
-> (3 : ([] ++ [4, 5, 6])) !! 1
-> ([] ++ [4, 5, 6]) !! 0
-> [4, 5, 6] !! 0
-> (4 : [5, 6]) !! 0
-> 4

[1, 2, 3, 4, 5, 6] !! 3
-> (1 : [2, 3, 4, 5, 6]) !! 3
-> [2, 3, 4, 5, 6] !! 2
-> (2 : [3, 4, 5, 6]) !! 2
-> [3, 4, 5, 6] !! 1
-> (3 : [4, 5, 6]) !! 1
-> [4, 5, 6] !! 0
-> (4 : [5, 6]) !! 0
-> 4

setN :: Int -> a -> [a] -> [a]
setN i x xs = take i xs ++ [x] ++ drop (i + 1) xs

(setN 2 11 (setN 2 8 [1, 2, 3, 4])) !! 2
           -----------------------
	       zs
-> (take 2 zs ++ [11] ++ drop 3 zs) !! 2
	zs
	-> take 2 [1, 2, 3, 4] ++ ([8] ++ drop 3 [1, 2, 3, 4])
	-> 1 : take 1 [2, 3, 4] ++ ([8] ++ drop 3 [1, 2, 3, 4])
	-> 1 : (take 1 [2, 3, 4] ++ ([8] ++ drop ...))
	       ---------------------------------------
	         ws
-> ((1 : ws) ++ ([11] ++ drop 3 (1 : ws))) !! 2
-> (1 : (ws ++ (...))) !! 2
-> (ws ++ (...)) !! 1

[1, 2, 3] ++ [4, 5, 6]
-> 1 : ([2, 3] ++ [4, 5, 6])
-> 1 : (2 : ([3] ++ [4, 5, 6])
-> 1 : (2 : (3 : ([] ++ [4, 5, 6])))
-> 1 : (2 : (3 : [4, 5, 6]))

(setN 1 11 (setN 1 9 [1, 2, 3, 4])) !! 1

setN 1 11 (setN 1 9 [1, 2, 3, 4])
take 1 (setN 1 9 [1, 2, 3, 4]) ++ [11] ++ drop 2 (setN 1 9 [1, 2, 3, 4])
take 1 (take 1 [1, 2, 3, 4] ++ [9] ++ drop 2 [1, 2, 3, 4]) ++ [11] ++ ...
take 1 ([1] ++ [9] ++ ...) ++ [11] ++ ...
[1] ++ [11] ++ ...

setN 2 11 (setN 2 9 [1, 2, 3, 4])
take 2 (setN 2 9 [1, 2, 3, 4]) ++ [11] ++ ...
take 2 (take 2 [1, 2, 3, 4] ++ [9] ++ ...) ++ [11] ++ ...
take 2 ([1, 2] ++ [9] ++ ...) ++ [11] ++ ...

([1, 2] ++ [3, 4, 5]) !! 2
-> (1 : ([2] ++ [3, 4, 5])) !! 2
-> ([2] ++ [3, 4, 5]) !! 1
-> (2 : ([] ++ [3, 4, 5])) !! 1
-> ([] ++ [3, 4, 5]) !! 0
-> [3, 4, 5] !! 0
-> 3

((1 : 2 : []) ++ (3 : 4 : [])) !! 2
-> (1 : ((2 : []) ++ (3 : 4 : []))) !! 2
-> ((2 : []) ++ (3 : 4 : [])) !! 1
-> (2 : ([] ++ (3 : 4 : []))) !! 1
-> ([] ++ (3 : 4 : [])) !! 0
-> (3 : 4 : []) !! 0
-> 3

(1 : 2 : 3 : 4 : []) !! 2
-> (2 : 3 : 4 : []) !! 1
-> (3 : 4 : []) !! 0
-> 3

2013.12.25 Wed.

参照透過性(状態変化)
第一級関数(高階関数)
遅延性
静的型付け
