第7回 リストを扱う再帰関数
==========================

はじめに
--------

リストについて学び、再帰関数について学んだ。
「くりかえし」を表現する場合、リストを使うと良い。

リストのところではリストを扱う関数を使った。
これらの関数群も再帰的に定義されている。
リストというデータ構造自体が再帰的である。

リストを扱う関数の再帰的な定義を見ていく。

リストとは
----------

リストは再帰的なデータ構造である。
以下の疑似コードを見てみよう。

    [a] = (a : [a]) or []

aのリストとは、aのリストの先頭にa型の値を足したもの、
または空リストである。

言いかたを変えると、空リストはaのリストであり、
aのリストの先頭にaを追加したものもaのリストである、となる。

試してみよう。

コマンドプロンプトを2つ立ち上げて、
lectures/lecture07ディレクトリを作成しておこう。
今作ったディレクトリに移動しておく。

    % ghci
    Prelude> [] :: [Int]
    []
    Prelude> 3 : [] :: [Int]
    [3]
    Prelude> 8 : 3 : [] :: [Int]
    [8, 3]

[]から始めて先頭に次々に値を加えていけるのがわかる。
これがリストの内部構造である。

構文糖
------

### リスト

今まで見てきた[1, 2, 3]といった表現は実は構文糖だった。
[1, 2, 3]は本当は1 : 2 : 3 : []という意味である。

厳密には区別されるが、今のところ(:)は演算子と考えておこう。
(:)は右結合なので、

    1 : 2 : 3 : []

と書くのは、以下と同じことだ。

    1 : (2 : (3 : []))

慣れてくると[x, y, z]とx : (y : (z : []))とが同じに見えるようになる。

### 文字列

前に説明したように文字列は文字のリストである。

    "hello"

これは以下のように解釈される。

    ['h', 'e', 'l', 'l', 'o']

さらにリストにおける構文糖についても脱糖すると

    'h' : 'e' : 'l' : 'l' : 'o' : []

括弧を明示すると

    'h' : ('e' : ('l' : ('l' : ('o' : []))))

慣れてくるとこれらも同じものに見えてくる。

パターンマッチ
--------------

### どのように行うか

#### リストが空でない場合

リストの内部構造がわかったので、リストのパターンマッチも理解できるだろう。

以下のような形となる。

    fun (x : xs) = ...

たとえば[1, 2, 3]を(x : xs)にパターンマッチさせることを考える。

    [1, 2, 3] == 1 : (2 : 3 : [])

なので、これを(x : xs)にパターンマッチさせると

    x == 1
    xs == 2 : 3 : [] == [2, 3]

となる。

つまり、パーンマッチによって、リストの先頭とそれ以外に分解することができる。

#### リストが空の場合

リストには(x : xs)という形のほかに、空リストを表す[]という形がある。

[]は(x : xs)にマッチしないので、

    fun (x : xs) = ...

とだけ定義されている関数funに空リストを与えるとエラーが生じる。
funを空リストの場合にも使えるようにするには、以下のようにする必要がある。

    fun [] = ...
    fun (x : xs) = ...

### headとtailの例

#### 試してみる

headとtailという関数が用意されている。

    Prelude> head [3, 1, 4, 1, 5, 9, 2]
    3
    Prelude> tail [3, 1, 4, 1, 5, 9, 2]
    [1, 4, 1, 5, 9, 2]
    Prelude> head "knight"
    'k'
    Prelude> tail "knight"
    "night"

#### 関数の意味

headはリストの一番目の要素を返す関数であり、
tailはリストの残りの要素を返す関数である。

myList.hsを作り以下の関数を作成しよう。

* 演習7-1. headと同じmyHeadを定義せよ
* 演習7-2. tailと同じmyTailを定義せよ
    + ヒント: パターンマッチを使う(1分)

#### 部分関数

myHeadとmyTailの定義のなかには[]に対する処理が書かれていない。
よってmyHeadやmyTailに空リストを与えるとエラーになる。
エラーとなる値が存在する関数を部分関数と呼ぶ。
これは標準ライブラリのheadやtailについても同じことである。

部分関数は大規模な開発では避けたほうが良い。
headやtailを使うのは「引数が絶対に空リストにならない」か、
「規模が大きくならない(使い捨ての関数等)」場合のみにしよう。

#### 試してみる

    % ghci myList.hs
    *Main> myHead [3, 1, 4, 1, 5, 9, 2]
    3
    *Main> myTail [3, 1, 4, 1, 5, 9, 2]
    [1, 4, 1, 5, 9, 2]
    *Main> myHead "knight"
    'k'
    *Main> myTail "knight"
    "night"

##### 空リストを与えてみる

    *Main> myHead []
    *** Exception: myList.hs:X:Y-Z: Non-exhaustive patterns in
    function myHead
    *Main> myTail []
    *** Exception: myList.hs:X:Y-Z: Non-exhaustive patterns in
    function myTail

#### エラーメッセージをわかりやすくする

myHeadの定義に以下を加え

    myHead [] = error "myHead: empty list"

myTailの定義に以下を加える

    myTail [] = error "myTail: empty list"

##### 試してみる

    *Main> :reload
    *Main> myHead []
    *** Exception: myHead: empty list
    *Main> myTail []
    *** Exception: myTail: empty list

ここまでのまとめ
----------------

リストの構造について説明した。
リストとは[](空リスト)、またはリストの先頭に値を足したものである。

[1, 2, 3]という表記は構文糖で、脱糖すると以下のようになる。

    1 : (2 : (3 : []))

[]と(x : xs)というパターンによってパターンマッチができる。
パターンマッチについてはheadとtailの例を見た。
headとtailは部分関数なので、大規模な開発では使わないほうが良い。

リストの総和・総積・長さ
------------------------

リストを扱う再帰的関数について学んでいく。
まずはリストの要素の総和を求める関数sumを見る。

### 総和を求める関数

#### 考えかた

* 空リストの総和は0
* 値xをリストxsに追加したリストの総和はx + リストxsの総和

#### 関数定義

そのまま書けば良い。
myList.hsに以下を書き込もう。

    mySum :: [Int] -> Int
    mySum [] = 0
    mySum (x : xs) = x + mySum xs

#### 試してみる

    *Main> :reload
    *Main> mySum [1, 5, 2, 3, 9]
    20
    *Main> mySum [3, 2, 3, 3, 5]
    16

### 総積を求める関数

#### 演習

リストの要素すべてをかけ合わせた値を返す関数がある。
総和に対して、これを総積と呼ぼう。
productという名前で用意されているが、これを定義してみよう。

* 演習7-3. リストの総積を求める関数myProductを定義せよ(1分)

答えをmyList.hsに書き込もう。

#### 試してみる

    *Main> :reload
    *Main> myProduct [3, 1, 4, 1, 5, 9, 2]
    1080
    *Main> myProduct [4, 4, 9, 2]
    288

### リストの長さを求める関数

#### 演習

* 演習7-4. リストの長さを求めるmyLengthを定義せよ(1分)

右結合でリストをまとめる
------------------------

### []と(:)を置き換える

#### mySumについて

mySumの定義をもう一度見てみる。

    mySum [] = 0
    mySum (x : xs) = x + mySum xs

別の角度から見ると以下のように考えられる。
mySumは

* []を0に置き換え
* (:)を(+)に置き換える

mySum [1, 2, 3, 4]は以下のような変換を行っていることになる。

       1 : (2 : (3 : (4 : [])))
    -> 1 + (2 + (3 + (4 + 0 )))

#### より一般的に

これはより一般的に考えることができる。

    fun [] = v
    fun (x : xs) = x `op` xs

funは[]をvに(:)をopに置き換える関数である。

       x0 :    (x1 :    (x2 :    (... (xn :    [])..)))
    -> x0 `op` (x1 `op` (x2 `op` (... (xn `op` v )..)))

左結合でリストをまとめる
------------------------

### 右結合と左結合

加算や乗算では右結合と左結合とで値は変わらない。

    1 + (2 + 3) == (1 + 2) + 3

しかし減算や除算では右結合と左結合で値が変わる。

    1 - (2 - 3) /= (1 - 2) - 3

リストの要素間の演算で右結合か左結合かが問題になることは多い。
今までは右結合の例を見てきたので、今度は左結合の例を見ていこう。

手始めに、左結合する総和関数の作りかたを見てみよう。

### mySum'

#### 問題定義

mySumは以下のような変換を行う。

       x0 : x1 : x2 : ... : []
    -> x0 + (x1 + (x2 + (... + 0)))

以下のような変換を行うmySum'を作りたい。

       x0 : x1 : x2 : ... : []
    -> ((0 + x0) + x1) + x2) ...

#### 蓄積変数

変換後の形をよく見ると、以下のことがわかる。

* x1までの計算をするとき(0 + x0)が必要
* x2までの計算をするとき((0 + x0) + x1)が必要
* ...

これらの「必要」な値を保存しておく変数が必要になる。

これを「蓄積変数」と呼ぶ。

#### 関数定義

mySum'の定義は以下のようになる。

    mySum' :: [Int] -> Int
    mySum' = mySumIter 0

    mySumIter :: Int -> [Int] -> Int
    mySumIter s [] = s
    mySumIter s (x : xs) = mySumIter (s + x) xs

sが蓄積変数である。
mySumIterはsにリストの要素の値を足していき、
リストが空になったらsを返す。

再帰的処理と反復的処理
----------------------

### 反復的処理

mySumIterの定義を見てみると

    mySumIter s (x : xs) = mySumIter (s + x) xs

引数だけ変化した同じ関数に完全に置き換えられている。
置き換えられていく様子を具体例で見てみよう。

       mySumIter 0 [1, 2, 3]
    -> mySumIter (0 + 1) [2, 3]
    -> mySumIter ((0 + 1) + 2) [3]
    -> mySumIter (((0 + 1) + 2) + 3) []
    -> ((0 + 1) + 2) + 3
    -> 6

これは内部的には単純な「くりかえし」として実行できる。
この関数は再帰的に定義されてはいるが「反復的処理」を行っている。

### 再帰的処理

mySumの定義にもどってみよう。

    mySum (x + xs) = x + mySum xs

この定義は引数だけを変えた置き換えにはなっていない。
つまり、単純な「くりかえし」には変換できない。

このような処理を「再帰的処理」と呼ぶ。

ここまで見てきたように、

* リストに対する再帰的処理は右結合の結果を返し
* リストに対する反復的処理は左結合の結果を返す

### 再帰的処理の抽象化

#### foldr

リストに対する再帰的処理の多くは以下の形をとる。

    fun [] = v
    fun (x : xs) = x `op` fun xs

この枠組みでvとopだけ変えればいろいろな関数が作れる。
このような枠組みをHaskellでは関数として抽象化できる。

    foldr op v [] = v
    foldr op v (x : xs) = x `op` foldr op v xs

理解のためにopに(+)をvに0をいれてみよう。

    foldr (+) 0 [] = 0
    foldr (+) 0 (x : xs) = x + foldr (+) 0 xs

これとmySumの定義をくらべてみる。

    mySum [] = 0
    mySum (x : xs) = x + mySum xs

以下の関係が成り立つことがわかるだろう。

    mySum == foldr (+) 0

#### myFoldr

foldrは標準ライブラリに用意されている。
myFoldrとして再定義してみよう。
myList.hsに以下を追加する。

    myFoldr op v [] = v
    myFoldr op v (x : xs) = x `op` myFoldr op v xs

試してみる。

    *Main> :reload
    *Main> myFoldr (+) 0 [1, 2, 3, 4]
    10
    *Main> myFoldr (*) 1 [1, 2, 3, 4]
    24

#### foldrの型

foldrの型を導き出してみよう。

    foldr op v [] = v
    foldr op v (x : xs) = x `op` foldr op v xs

foldrは引数を3つ取る関数なので仮に以下のような型であるとする。

    foldr :: X -> Y -> Z -> R

* 第3引数は「何かのリスト」なのでZ = [a]とする
* 第2引数vがそのまま返り値となっているのでY = Rとなる
* これをbと置く、つまりY = R = b
* x `op` foldr op v xsが全体の返り値(型b)となるのでopは
    + (x :: a)と(foldr op v xs :: b)を引数としてとり
    + bを返り値として返す
* つまりop :: a -> b -> b

よって最終的には以下のようになる

    X = a -> b -> b
    Y = b
    Z = [a]
    R = b

よって

    foldr :: (a -> b -> b) -> b -> [a] -> b

### 反復的処理の抽象化

#### foldl

#### foldlの型

#### myFoldl

ここまでのまとめ
----------------

その他の関数
------------

まとめ
------
