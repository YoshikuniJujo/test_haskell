第7回 リストを扱う再帰関数
==========================

はじめに
--------

リストについて学び、再帰関数について学んだ。
「くりかえし」を表現する場合、リストを使うと良い。

リストのところではリストを扱う関数を使った。
これらの関数群も再帰的に定義されている。
リストというデータ構造自体が再帰的である。

リストを扱う関数の再帰的な定義を見ていく。

リストとは
----------

リストは再帰的なデータ構造である。
以下の疑似コードを見てみよう。

    [a] = (a : [a]) or []

aのリストとは、aのリストの先頭にa型の値を足したもの、
または空リストである。

言いかたを変えると、空リストはaのリストであり、
aのリストの先頭にaを追加したものもaのリストである、となる。

試してみよう。

コマンドプロンプトを2つ立ち上げて、
lectures/lecture07ディレクトリを作成しておこう。
今作ったディレクトリに移動しておく。

    % ghci
    Prelude> [] :: [Int]
    []
    Prelude> 3 : [] :: [Int]
    [3]
    Prelude> 8 : 3 : [] :: [Int]
    [8, 3]

[]から始めて先頭に次々に値を加えていけるのがわかる。
これがリストの内部構造である。

構文糖
------

### リスト

今まで見てきた[1, 2, 3]といった表現は実は構文糖だった。
[1, 2, 3]は本当は1 : 2 : 3 : []という意味である。

厳密には区別されるが、今のところ(:)は演算子と考えておこう。
(:)は右結合なので、

    1 : 2 : 3 : []

と書くのは、以下と同じことだ。

    1 : (2 : (3 : []))

慣れてくると[x, y, z]とx : (y : (z : []))とが同じに見えるようになる。

### 文字列

前に説明したように文字列は文字のリストである。

    "hello"

これは以下のように解釈される。

    ['h', 'e', 'l', 'l', 'o']

さらにリストにおける構文糖についても脱糖すると

    'h' : 'e' : 'l' : 'l' : 'o' : []

括弧を明示すると

    'h' : ('e' : ('l' : ('l' : ('o' : []))))

慣れてくるとこれらも同じものに見えてくる。

パターンマッチ
--------------

### どのように行うか

#### リストが空でない場合

リストの内部構造がわかったので、リストのパターンマッチも理解できるだろう。

以下のような形となる。

    fun (x : xs) = ...

たとえば[1, 2, 3]を(x : xs)にパターンマッチさせることを考える。

    [1, 2, 3] == 1 : (2 : 3 : [])

なので、これを(x : xs)にパターンマッチさせると

    x == 1
    xs == 2 : 3 : [] == [2, 3]

となる。

つまり、パーンマッチによって、リストの先頭とそれ以外に分解することができる。

#### リストが空の場合

リストには(x : xs)という形のほかに、空リストを表す[]という形がある。

[]は(x : xs)にマッチしないので、

    fun (x : xs) = ...

とだけ定義されている関数funに空リストを与えるとエラーが生じる。
funを空リストの場合にも使えるようにするには、以下のようにする必要がある。

    fun [] = ...
    fun (x : xs) = ...

### headとtailの例

#### 試してみる

headとtailという関数が用意されている。

    Prelude> head [3, 1, 4, 1, 5, 9, 2]
    3
    Prelude> tail [3, 1, 4, 1, 5, 9, 2]
    [1, 4, 1, 5, 9, 2]
    Prelude> head "knight"
    'k'
    Prelude> tail "knight"
    "night"

#### 関数の意味

headはリストの一番目の要素を返す関数であり、
tailはリストの残りの要素を返す関数である。

myList.hsを作り以下の関数を作成しよう。

* 演習7-1. headと同じmyHeadを定義せよ
* 演習7-2. tailと同じmyTailを定義せよ
    + ヒント: パターンマッチを使う(1分)

#### 部分関数

myHeadとmyTailの定義のなかには[]に対する処理が書かれていない。
よってmyHeadやmyTailに空リストを与えるとエラーになる。
エラーとなる値が存在する関数を部分関数と呼ぶ。
これは標準ライブラリのheadやtailについても同じことである。

部分関数は大規模な開発では避けたほうが良い。
headやtailを使うのは「引数が絶対に空リストにならない」か、
「規模が大きくならない(使い捨ての関数等)」場合のみにしよう。

#### 試してみる

    % ghci myList.hs
    *Main> myHead [3, 1, 4, 1, 5, 9, 2]
    3
    *Main> myTail [3, 1, 4, 1, 5, 9, 2]
    [1, 4, 1, 5, 9, 2]
    *Main> myHead "knight"
    'k'
    *Main> myTail "knight"
    "night"

##### 空リストを与えてみる

    *Main> myHead []
    *** Exception: myList.hs:X:Y-Z: Non-exhaustive patterns in
    function myHead
    *Main> myTail []
    *** Exception: myList.hs:X:Y-Z: Non-exhaustive patterns in
    function myTail

#### エラーメッセージをわかりやすくする

myHeadの定義に以下を加え

    myHead [] = error "myHead: empty list"

myTailの定義に以下を加える

    myTail [] = error "myTail: empty list"

##### 試してみる

    *Main> :reload
    *Main> myHead []
    *** Exception: myHead: empty list
    *Main> myTail []
    *** Exception: myTail: empty list

ここまでのまとめ
----------------

リストの構造について説明した。
リストとは[](空リスト)、またはリストの先頭に値を足したものである。

[1, 2, 3]という表記は構文糖で、脱糖すると以下のようになる。

    1 : (2 : (3 : []))

[]と(x : xs)というパターンによってパターンマッチができる。
パターンマッチについてはheadとtailの例を見た。
headとtailは部分関数なので、大規模な開発では使わないほうが良い。

リストの総和・総積・長さ
------------------------

リストを扱う再帰的関数について学んでいく。
まずはリストの要素の総和を求める関数sumを見る。

### 総和を求める関数

#### 考えかた

* 空リストの総和は0
* 値xをリストxsに追加したリストの総和はx + リストxsの総和

#### 関数定義

そのまま書けば良い。
myList.hsに以下を書き込もう。

    mySum :: [Int] -> Int
    mySum [] = 0
    mySum (x : xs) = x + mySum xs

#### 試してみる

    *Main> :reload
    *Main> mySum [1, 5, 2, 3, 9]
    20
    *Main> mySum [3, 2, 3, 3, 5]
    16

### 総積を求める関数

右結合でリストをまとめる
------------------------

左結合でリストをまとめる
------------------------

再帰的処理と反復的処理
----------------------

### 反復的処理

### 再帰的処理

### 再帰的処理の抽象化

### 反復的処理の抽象化

ここまでのまとめ
----------------

その他の関数
------------

まとめ
------
