第5回 演習
==========

はじめに
--------

今日は関数、型、タプル、リストについて学んだ。
タプルのところではパターンマッチについても学んだ。
今の知識でできる演習問題を見ていくことにしよう。
モンテカルロ法で円周率を求める方法を見ていこう。
必要となる関数を演習問題として出していく。

モンテカルロ法とは
------------------

### モンテカルロとは

カジノで有名なモナコ公国の1地区

### モンテカルロ法とは

乱数を使うことで「決まった時間内」に
「正しい可能性の高い結果」が得られる。
本当に正しいのかどうかはわからない。
一種の賭けである。

だから「モンテカルロ」法。

円周率を求めるアルゴリズム
--------------------------

円周率は半径1の円の面積に等しいので、
「円周率を求める」は「半径1の円の面積を求める」と言い換えることができる。

1辺が2の正方形のなかに半径1の円を書く。
ランダムに点を打つ。

すると、以下の値が円の面積に近づいていくと予測できる。

    円の中にある点の数 / 全体の点の数 * 4

![image1] (monteImage.png "medium")

追加の構文
----------

演習で使う追加の構文を見てみよう。

### import

指定したモジュールから指定した関数を取り込む。

    import [モジュール名] ([識別子1], [識別子2] ...)

### where

where以下に関数ローカルな環境を作る。

    fun x = y + z
    where
    y = x * 2
    z = 1 / x

### 型指定

値にオプショナルな型指定をつけることができる。

    (3 :: Int) + 8

追加の関数
----------

以下のまだ説明していない関数を使う。

    (^), (<=), fromIntegral, fst, snd, tail,
    take, length, cycle, zip, randomRs, mkStdGen

ひとつずつ説明していく。

### べき乗

(^)はべき乗を表す関数(演算子)である。
xのn乗を以下のように表す。

    x ^ n

試してみる
(ついでにlecture05ディレクトリを作っておく)。

    % cd lectures
    % mkdir lecture05
    % cd lecture05
    % ghci
    Prelude> 3 ^ 3
    27
    Prelude> 5 ^ 4
    625

### 小なりイコール

(<=)は「小なりイコール」を表す関数(演算子)である。

    x <= y

これは、xがyと等しいかまたは小さいときTrueを返し、
xがyより大きいときにFalseを返す。

試してみる。

    Prelude> 7 <= 11
    True
    Prelude> 9 <= 9
    True
    Prelude> 15 <= 6
    False

### fromIntegral

fromIntegralは整数を他の型の数に変換する関数である。

    fromIntegral x

これはxを他の型の数に変換した値を返す。

試してみる。

    Prelude> fromIntegral (21 :: Int) :: Double
    21.0
    Prelude> fromIntegral (103 :: Int) :: Double
    103.0

### 2要素タプルからの取り出し

タプルからの要素の取り出しにはパターンマッチが使える。

    fun (x, y) = ...

2要素タプルには要素を取り出す関数が用意されている。

* fst: タプルの一番目の要素を取り出す
* snd: タプルの二番目の要素を取り出す

以下のように定義できる。

    fst :: (a, b) -> a
    fst (x, _) = x

    snd :: (a, b) -> b
    snd (_, y) = y

試してみる。

    Prelude> fst (8, 'f')
    8
    Prelude> snd (8, 'f')
    'f'

### tail

tailはリストの先頭以外の要素を返す関数である。

型は以下のようになる。

    tail :: [a] -> [a]

試してみる。

    Prelude> tail [3, 8, 4, 2, 5]
    [8, 4, 2, 5]
    Prelude> tail "swords"
    "words"

### take

takeはリストのはじめのn要素を取り出す関数である。

    take :: Int -> [a] -> [a]

試してみる。

    Prelude> take 3 [2, 5, 8, 9, 4]
    [2, 5, 8]
    Prelude> take 4 [9, 8, 2, 1, 11, 5, 3]
    [9, 8, 2, 1]
    Prelude> take 4 "monkey"
    "monk"

### length

lengthはリストの長さを返す関数である。

    length :: [a] -> Int

試してみる。

    Prelude> length [3, 2, 4, 9, 1]
    5
    Prelude> length "Hello, world!"
    13

### cycle

cycleはリストを無限にくりかえす関数である。

    cycle :: [a] -> [a]

そのまま対話環境に打ち込むとプロンプトが返ってこなくなる。
ためすときはtakeと組み合わせると良い。

試してみる。

    Prelude> take 20 $ cycle [8, 2, 1, 5, 9]
    [8,2,1,5,9,8,2,1,5,9,8,2,1,5,9,8,2,1,5,9]
    Prelude> take 35 $ cycle "rose"
    "roseroseroseroseroseroseroseroseros"

### zip

zipは2つのリストをタプルのリストに合成する関数である。

    zip :: [a] -> [b] -> [(a, b)]

試してみる。

    Prelude> zip [3, 8, 5, 2, 1, 9] "hello"
    [(3,'h'),(8,'e'),(5,'l'),(2,'l'),(1,'o')]
    Prelude> zip "laugh" [1 ..]
    [('l',1),('a',2),('u',3),('g',4),('h',5)]

### ランダム

モンテカルロ法を使うためにはランダムな数列が必要となる。

#### randomRs

System.RandomモジュールのrandomRsを使う。

randomRsの型は以下のように考えられる。

    randomRs :: (Double, Double) -> StdGen -> [Double]

第1引数はタプルで、ランダム値の(下限、上限)を指定する。

#### StdGen

第2引数のStdGenは見たことのない型だ。
ランダム関数には初期値が必要であり、
これをランダムの種と呼ぶ。
StdGenはランダムの種であり、
整数(Int)からStdGenへの変換関数が用意されている。

    mkStdGen :: Int -> StdGen

試してみる(itは直前に評価された値に束縛される)。

    Prelude> :m System.Random 4492
    4493 1
    Prelude System.Random> :type it
    it :: StdGen

mkStdGenでStdGenの値が得られることがわかる。

#### ランダムな値

実際にランダムな値を取り出してみる。

    Prelude System.Random> take 3 $ randomRs (1.0, 3) $ mkStdGen 4492
    [1.3340016134650776,2.6353743186525085,1.203265205046218]
    Prelude System.Random> take 3 $ randomRs (1.0, 3) $ mkStdGen 129
    [2.8007050950763306,1.1983942696826542,2.0151573577576363]
    Prelude System.Random> take 3 $ randomRs (1.0, 3) $ mkStdGen 129
    [2.8007050950763306,1.1983942696826542,2.0151573577576363]

別の種には別の乱数列が生成され、
同じ種には同じ乱数列が生成されているのがわかる。

Haskellの関数は同じ引数には同じ値を返す。
これを参照透過性と呼ぶ。

円のなか
--------

montePi.hsを作ってエディタで開いておく。
ghciで読み込んでおこう。

    % ghci montePi.hs
    *Main>

点(x, y)が「中心(0, 0)の半径1の円」のなかに
あることを検査する関数inCircleを作る。

* 演習1. inCircleの型を決めよう(1分)
* 演習2. inCircleの中身を作ろう(2分)

解答をmontePi.hsに書き込もう。

試してみる。

    *Main> :reload
    *Main> inCircle 0.5 0.5
    True
    *Main> inCircle 0.8 (- 0.8)
    False
    *Main> inCircle 1 0
    True

数列をペアに区切る
------------------

### 何に使うのか

(0, 0)を中心にする1辺2の正方形内のランダムな点が必要だ。
ランダムな点を(x, y)とすると、この場合、
xとyの値の範囲は両方とも-1から1となる。
xとyの値の範囲が同じなので、
フラットなランダム列を2つずつに区切れば良い。

再帰関数を使えば簡単だが、今の知識だけでも、多少技巧的だが、できる。
数列を数のペアの列にする関数pairsを考えよう。

### どのように作るか

以下のようなやりかたにする。

数列dsとdsをひとつずらしたds'の要素同士をペアにする。

    ds  = [a, b, c, d, e, f ...]
    ds' = [b, c, d, e, f ...]
    ps = [(a, b), (b, c), (c, d), (d, e), (e, f) ...]

これをひとつ置きに取っていく。

    ps' = [(a, b), (c, d), (e, f) ...]

### 列からひとつ置きに取る

#### どのように作るか

列からひとつ置きに取るには以下のようにすれば良い。

True, Falseをくりかえす列とのzipをとる。

    tfs = [True, False, True, Flase, True, False ...]
    lst = [a, b, c, d, e ...]
    ps = [(True, a), (False, b), (True, c) ...]

ペアのひとつめがTrueであるものだけを集める。

    ps' = [(True, a), (True, c), (True, e) ...]

ペアのふたつめをとる。

    lst' = [a, c, e ...]

#### True, Falseをくりかえす

* 演習3. True, Falseをくりかえすtfsを定義せよ(1分)

解答をmontePi.hsに書き込み、試してみる。

    *Main> :reload
    *Main> take 7 tfs
    [True, False, True, False, True, False, True]

#### ひとつ置きに取る

ひとつ置きに取る戦略をおさらいする。

1. tfsとのzipをとる(zipは各要素同士のペア)
2. ペアの1番目の値でfilterする
3. ペアの2番目の値だけをとる

これを行う関数をhopとする。

* 演習4. hopの型を決めよ(1分)
* 演習5. hopの中身を作れ(2分)

montePi.hsに書き込み、試してみる。

    *Main> :reload
    *Main> hop [1 .. 10]
    [1, 3, 5, 7, 9]

### ペアに区切る

1. リストとそれ自体をひとつじらしたリストとをzipする
2. 結果として出来たリストの要素をひとつ置きに取る

この関数をpairsとする。

* 演習6. pairsの型を決めよ(1分)
* 演習7. pairsの中身を作れ(2分)

montePi.hsに書き込み、試してみる。

    *Main> :reload
    *Main> pairs [1 .. 10]
    [(1,2),(3,4),(5,6),(7,8),(9,10)]
    *Main> paris "Haskell"
    [('H','a'),('s','k'),('e','l')]

ランダムな点
------------

ランダムの種を与えるとランダムな点のリストを返す関数を作る。

点の範囲はx, yともに-1から1のあいだとする。
つまり、中心が(0, 0)の1辺が2の正方形ということだ。

この関数をpointsという名前にする。
ランダムの種の型はStdGenとする。
また与えられた範囲の乱数列を返す関数は以下で与えられる。

    randomRs :: (Double, Double) -> StdGen -> [Double]

* 演習8. pointsの型を決めよ(1分)
* 演習9. pointsの中身を作れ(2分)

montePi.hsに書き込む。
System.Random関数の関数を使うので、以下をファイルの先頭に追加する。

    import System.Random (randomRs, mkStdGen)

試してみる。

    *Main> :reload
    *Main> take 3 $ points $ mkStdGen 8
    [(0.20459894277856527,0.24663064721415995),
     (0.9771447330621963,0.9783704164014069),
     (0.18987081493684044,0.9168931043632724)]
    *Main> take 3 $ points $ mkStdGen 100
    [(0.3437710368021347,0.6563294470855043),
     (-2.515042527274768e-2,-0.3169208662294889),
     (-0.6213147009867743,-3.3271138062613836e-2)]

πの値を求める
-------------

モンテカルロ法でπの値を求める。

### やりかた

半径1の円の面積を求めれば良い。
関数getPiについて考える。
getPiは点を打つ数とランダムの種を入力としてπの近似値を出力とする。

n個のランダムの点のうち円内の点を選び、
その数をnでわったものを求める。
それに正方形の面積である4をかける。

### getPiの型

* 演習10. getPiの型を決めよ(1分)

### getPiの定義

getPiの定義は以下のようになる。

    getPi n sg = 4 * fromIntegral (length inps) / fromIntegral n
        where inps = [ (a) ]

整数Intと浮動小数点Doubleとでは型が異なる。
点の個数nやリストの長さlengthはInt型であり、
円周率はDouble型である。
fromIntegralでIntからDoubleに型を変換している。

円内の点の数を全体の点の数で割ったものに4をかけている。

つまり、inpsはn個のランダムな点のうち、円内にある点のリストである。

* 演習11. getPiの定義における[ (a) ]に入る式を求めよ(1分)

できた!
-------

### 試してみる

getPi関数をmontePi.hsに書き込み、試してみよう。

    *Main> :reload
    *Main> getPi 100 $ mkStdGen 10
    3.08
    *Main> getPi 1000 $ mkStdGen (-7)
    3.12
    *Main> getPi 10000 $ mkStdGen 123
    3.17
    *Main> getPi 100000 $ mkStdGen 293
    3.13572

### 結果について

ランダムの種の違いによって値は大きく変化する。
結果は「正しい可能性が高」く、試行を増やせば「正しい可能性は高」まる。
しかし、必ずしも値に近づいていくとは限らない。

円周率には近似値を求める効率的なアルゴリズムがあるので、
モンテカルロ法を使う必要はない。

正しい値を求めるアルゴリズムの計算量が膨大であるときに
モンテカルロ法は役に立つ。

まとめ
------

モンテカルロ法で円周率を求める関数を作った。
そこで使われる関数を定義していくことで、関数を作る/使う練習をした。
リストを扱う関数の使いかたも学んだ。

直接、再帰的定義を使わなくてもリストを扱う関数でかなりのことができることを学んだ。
