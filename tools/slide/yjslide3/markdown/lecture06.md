第6回 再帰関数
==============

はじめに
--------

再帰関数は関数型言語の魂と呼べる。
再帰関数を使えば、
「くりかえし」を含むさまざまな処理の流れが表現可能である。

前回のリストを処理する関数群も再帰的に定義されている。
非常に強力な道具であり、
再帰関数を使えば、ほとんど「何でもできる」が、
直接的に再帰関数を使う前に
より力の弱い方法で実力できないかと考えたほうが良い。
つまり、再帰を使うのではなくmapやfilterを使う、等である。

強力な方法を使うよりも、より「飼い慣らされた」方法を使うほうが、
プログラムがわかりやすくなることが多い。

二乗の和
--------

### はじめに

「リスト」の回でやった二乗の和を再帰的に見ていく。
前回のやりかたのほうがプログラムはわかりやすいので、
この例の場合はリストを使うほうが良い。
しかし、再帰的に見ることによって、
より低レベルの「仕組み」が理解できる。
また、より広い範囲に応用できる。

### 問題定義

与えられた引数nに対して0からnまでの数の二乗の和を求める。

### 考えかた

#### リストを使った解 (復習)

1. 0からnまでのリストがあるとする
2. そのすべての要素を二乗したリストがあれば
3. そのリストの要素の総和が求める値である

#### 直接的に再帰を使った解

1. 0から0までの二乗の和は0である
2. 0から(n - 1)までの二等の和Sがあれば
3. 0からnまでの二乗の和はn ^ 2 + Sとなる

### 関数の再帰的な定義

1. 0から0までの二乗の和は0である
    * squareSum 0 = 0
2. 0から(n - 1)までの二乗の和Sがあれば
    * SはsquareSum (n - 1)
3. 0からnまでの二乗の和はn ^ 2 + S
    * squareSum n = n ^ 2 + squareSum (n - 1)

よって以下のようになる。

    squareSum :: Int -> Int
    squareSum 0 = 0
    squareSum n = n ^ 2 + squareSum (n - 1)

### 試してみる

より詳細な説明をする前に実際に動かしてみる。
lectures/lecture06ディレクトリを作成しそこに移動する。

    % mkdir lectures/lecture06
    % cd lectures/lecture06
    % [エディタ] squareSum.hs

squareSum.hsを作成して、

    squareSum :: Int -> Int
    squareSum 0 = 0
    squareSum n = n ^ 2 + squareSum (n - 1)

コマンドプロンプトをもう1つ立ち上げる。

ghciに読み込もう。

    % ghci squareSum.hs
    *Main> squareSum 3
    14
    *Main> squareSum 8
    204

### 何故動くのか

どうしてこれが動くのだろうか。

定義は以下のようになっている。

    squareSum 0 = 0
    squareSum n = n ^ 2 + squareSum (n - 1)

1から順に見ていこう。

n = 1では以下のようになる。

    squareSum 1 = 1 ^ 2 + squareSum (1 - 1)
    squareSum 1 = 1 ^ 2 + squareSum 0
    squareSum 1 = 1 ^ 2 + 0
    squareSum 1 = 1 + 0
    squareSum 1 = 1

n = 2では以下のようになるだろう。

    squareSum 2 = 2 ^ 2 + squareSum (2 - 1)
    squareSum 2 = 2 ^ 2 + squareSum 1
    squareSum 2 = 2 ^ 2 + 1
    squareSum 2 = 4 + 1
    squareSum 2 = 5

### ひとつ前を使う

ひとつ前の値を使って次の値を求めている。

    n = 0のときの値を使ってn = 1の値を求め
    n = 1のときの値を使ってn = 2の値を求め
    n = 2のときの値を使ってn = 3の値を求め
    ...
    n = k - 1の値を使ってn = kの値を求め
    ...

このようにしてnが0以上のすべての整数について値が求まることになる。

### squareSumの意味

今度は定義をそのまま読んでみよう。

    squareSum 0 = 0
    squareSum n = n ^ 2 + squareSum (n - 1)

これは以下のように読める。

    0から0の値の二乗の和は0
    0からnの値の二乗の和は0から(n - 1)の二乗の和にn ^ 2を足したもの

動作ではなく「事実」を記述している。
つまり、動かさなくても字面からプログラムの意味がわかる。

### 再帰関数を作るコツ

1. 最もシンプルな部分(基底)を作る
2. その関数自体がすでに定義されていると考えて
    * より基底に近い定義から次の値を定義する

#### squareSumの場合

上記をsquareSumの場合に適用すると

1. 引数0の場合が基底となる
2. squareSumがすでに定義ずみと考えて
    * squareSum (n - 1)を使ってsquareSum n を定義する

nより(n - 1)のほうが0に近いという点が重要である。
つまり1を引くという動作をくりかえすことで0に到達するということ。

### 逐次的な評価

「再帰」を理解することがHaskellを理解する鍵のひとつなので、
理解のために様々な側面からの説明を続ける。

squareSumの逐次的な評価を見てみよう。

    squareSum 3
    -> 3 ^ 2 + squareSum (3 - 1)
    -> 3 ^ 2 + squareSum 2
    -> 3 ^ 2 + (2 ^ 2 + squareSum (2 - 1))
    -> 3 ^ 2 + (2 ^ 2 + squareSum 1)
    -> 3 ^ 2 + (2 ^ 2 + (1 ^ 2 + squareSum (1 - 1)))
    -> 3 ^ 2 + (2 ^ 2 + (1 ^ 2 + squareSum 0))
    -> 3 ^ 2 + (2 ^ 2 + (1 ^ 2 + 0))
    -> 3 ^ 2 + (2 ^ 2 + (1 + 0))
    -> 3 ^ 2 + (2 ^ 2 + 1)
    -> 3 ^ 2 + (4 + 1)
    -> 3 ^ 2 + 5
    -> 9 + 5
    -> 14

### 再帰関数を理解するコツ

#### 仮説を立てる

再帰関数を見たら2つの方法で理解を試みる。

* 字面から「何であるか」をとらえようとする
* 簡単なケースで逐次的評価を書きくだす

この2つの方法を試すことで仮説を立てることができる。
この作業には何度かの試行錯誤が必要になるかもしれない。

その関数が何であるかの仮説を立てたらそれを検証する。

#### 仮説を検証する

squareSumの定義を読んで以下の仮説を立てたとする。

    squareSum nは0からnまでの値の二乗の和である

関数の定義がその仮説と合致することを確認する。

    squareSum 0 = 0

0のとき仮説は正しい。

    squareSum n = n ^ 2 + squareSum (n - 1)

仮説が正しければ、右辺は0からnまでの二乗の和(1)であり、
左辺はnの二乗に0から(n - 1)までの二乗の和を足したもの(2)である。

(1)と(2)は等しいので、仮説と定義のあいだに矛盾はない。

### まとめ

squareSumを例に再帰関数の定義のしかたを見た。
また、再帰関結の定義から意味を理解するやりかたを見た。

再帰関数を作るときは、最もシンプルな基底ケースを書き、
「次」の値を「前」の値から導く定義を書く。

再帰関数を読むときは、「字面を見る」や「逐次的評価」によって仮説を立て、
仮説が定義と矛盾しないことを検証すれば良い。

木構造再帰
----------

### はじめに

リストやリストを扱う関数だけで実現できない処理が存在する。
単純な「くりかえし」より複雑な処理の場合、直接的に再帰を扱う必要がある。

制御の流れが「木構造」となる関数の例を見ていこう。

### 問題定義

以下のような木を考える

![tree](treeImage.png "large")

このような木について、
ある節から別の節への経路があるかどうかを返す関数をexistPathとする。

関数exitPathについて考えていこう。

### 新たに必要になる構文

#### 関数のガード節

条件によって式を選ぶことができる。

    fun x
        | even x = "even"
        | otherwise = "odd"

#### case式

関数の引数部分以外でもパターンマッチが使える。

    fun n = case n `mod` 3 of
        0 -> "3でわりきれる"
        _ -> "3でわりきれない"

#### タイプシノニム

    type [型名] = [型の表現]

型の別名をつくることができる。
[型名]が出てきたところはすべて[型の表現]で置き換えることができる。
プログラムの意味を読む人にわかりやすくする。
また、長い型を記述する手間を減らすことができる。
以下に例を挙げる。

    type Name = String
    type Age = Int
    type HumanList = [(Name, Age)]

### 新たに必要になる型

#### Maybe型

たとえば、Maybe Intという型は以下の値を持つ。

    Just [整数], Nothing

失敗する可能性のある計算に使われる。

計算が成功した場合には

    Just [結果]

計算が失敗した場合には

    Nothing

### 新たに必要になる関数

#### lookup

    lookup :: a -> [(a, b)] -> Maybe b

lookup x lstとすると、lstの要素である対のなかに、
対の1番目がxであるようなものがあれば、その対の2番目の値を返し、
なければNothingを返す。

#### (||)

    (||) :: Bool -> Bool -> Bool

2つのBool値の論理和(または)を返す関数である。
b1 || b2はb1またはb2のどちらかがTrueならばTrueとなる。

### 細かい条件

* 木は下向きにしかたどれない
* 子要素は0または2個
