第6回 再帰関数
==============

はじめに
--------

再帰関数は関数型言語の魂と呼べる。
再帰関数を使えば、
「くりかえし」を含むさまざまな処理の流れが表現可能である。

前回のリストを処理する関数群も再帰的に定義されている。
非常に強力な道具であり、
再帰関数を使えば、ほとんど「何でもできる」が、
直接的に再帰関数を使う前に
より力の弱い方法で実力できないかと考えたほうが良い。
つまり、再帰を使うのではなくmapやfilterを使う、等である。

強力な方法を使うよりも、より「飼い慣らされた」方法を使うほうが、
プログラムがわかりやすくなることが多い。

二乗の和
--------

### はじめに

「リスト」の回でやった二乗の和を再帰的に見ていく。
前回のやりかたのほうがプログラムはわかりやすいので、
この例の場合はリストを使うほうが良い。
しかし、再帰的に見ることによって、
より低レベルの「仕組み」が理解できる。
また、より広い範囲に応用できる。

### 問題定義

与えられた引数nに対して0からnまでの数の二乗の和を求める。

### 考えかた

#### リストを使った解 (復習)

1. 0からnまでのリストがあるとする
2. そのすべての要素を二乗したリストがあれば
3. そのリストの要素の総和が求める値である

#### 直接的に再帰を使った解

1. 0から0までの二乗の和は0である
2. 0から(n - 1)までの二等の和Sがあれば
3. 0からnまでの二乗の和はn ^ 2 + Sとなる

### 関数の再帰的な定義

1. 0から0までの二乗の和は0である
    * squareSum 0 = 0
2. 0から(n - 1)までの二乗の和Sがあれば
    * SはsquareSum (n - 1)
3. 0からnまでの二乗の和はn ^ 2 + S
    * squareSum n = n ^ 2 + squareSum (n - 1)

よって以下のようになる。

    squareSum :: Int -> Int
    squareSum 0 = 0
    squareSum n = n ^ 2 + squareSum (n - 1)

### 試してみる

より詳細な説明をする前に実際に動かしてみる。
lectures/lecture06ディレクトリを作成しそこに移動する。

    % mkdir lectures/lecture06
    % cd lectures/lecture06
    % [エディタ] squareSum.hs

squareSum.hsを作成して、

    squareSum :: Int -> Int
    squareSum 0 = 0
    squareSum n = n ^ 2 + squareSum (n - 1)

コマンドプロンプトをもう1つ立ち上げる。

ghciに読み込もう。

    % ghci squareSum.hs
    *Main> squareSum 3
    14
    *Main> squareSum 8
    204

### 何故動くのか

どうしてこれが動くのだろうか。

定義は以下のようになっている。

    squareSum 0 = 0
    squareSum n = n ^ 2 + squareSum (n - 1)

1から順に見ていこう。

n = 1では以下のようになる。

    squareSum 1 = 1 ^ 2 + squareSum (1 - 1)
    squareSum 1 = 1 ^ 2 + squareSum 0
    squareSum 1 = 1 ^ 2 + 0
    squareSum 1 = 1 + 0
    squareSum 1 = 1

n = 2では以下のようになるだろう。

    squareSum 2 = 2 ^ 2 + squareSum (2 - 1)
    squareSum 2 = 2 ^ 2 + squareSum 1
    squareSum 2 = 2 ^ 2 + 1
    squareSum 2 = 4 + 1
    squareSum 2 = 5

### ひとつ前を使う

ひとつ前の値を使って次の値を求めている。

    n = 0のときの値を使ってn = 1の値を求め
    n = 1のときの値を使ってn = 2の値を求め
    n = 2のときの値を使ってn = 3の値を求め
    ...
    n = k - 1の値を使ってn = kの値を求め
    ...

このようにしてnが0以上のすべての整数について値が求まることになる。

### squareSumの意味

今度は定義をそのまま読んでみよう。

    squareSum 0 = 0
    squareSum n = n ^ 2 + squareSum (n - 1)

これは以下のように読める。

    0から0の値の二乗の和は0
    0からnの値の二乗の和は0から(n - 1)の二乗の和にn ^ 2を足したもの

動作ではなく「事実」を記述している。
つまり、動かさなくても字面からプログラムの意味がわかる。

### 再帰関数を作るコツ

1. 最もシンプルな部分(基底)を作る
2. その関数自体がすでに定義されていると考えて
    * より基底に近い定義から次の値を定義する

#### squareSumの場合

上記をsquareSumの場合に適用すると

1. 引数0の場合が基底となる
2. squareSumがすでに定義ずみと考えて
    * squareSum (n - 1)を使ってsquareSum n を定義する

nより(n - 1)のほうが0に近いという点が重要である。
つまり1を引くという動作をくりかえすことで0に到達するということ。

### 逐次的な評価

「再帰」を理解することがHaskellを理解する鍵のひとつなので、
理解のために様々な側面からの説明を続ける。

squareSumの逐次的な評価を見てみよう。

    squareSum 3
    -> 3 ^ 2 + squareSum (3 - 1)
    -> 3 ^ 2 + squareSum 2
    -> 3 ^ 2 + (2 ^ 2 + squareSum (2 - 1))
    -> 3 ^ 2 + (2 ^ 2 + squareSum 1)
    -> 3 ^ 2 + (2 ^ 2 + (1 ^ 2 + squareSum (1 - 1)))
    -> 3 ^ 2 + (2 ^ 2 + (1 ^ 2 + squareSum 0))
    -> 3 ^ 2 + (2 ^ 2 + (1 ^ 2 + 0))
    -> 3 ^ 2 + (2 ^ 2 + (1 + 0))
    -> 3 ^ 2 + (2 ^ 2 + 1)
    -> 3 ^ 2 + (4 + 1)
    -> 3 ^ 2 + 5
    -> 9 + 5
    -> 14

### 再帰関数を理解するコツ
