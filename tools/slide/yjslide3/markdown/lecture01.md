第1回 関数
==========

はじめに
--------

Haskellでプログラミングをするということは、
関数を様々なやりかたで組み合わせるということだ。
関数の定義のしかた、関数へ引数を与えるやりかた、
関数の部分適用について見ていく。

また、関数のリテラル表記についても見る。
高階関数について学び、また、演算子と関数が同じものであることも学ぶ。

便利な演算子(.)と($)も紹介する。

関数定義と適用
--------------

### 関数の定義

C言語では以下のようにする。

    init add (int x, int y) { return x + y; }

同じことをHaskellでは以下のようにする。

    add x y = x + y

[関数名] [仮引数1] [仮引数2] ... = [表現]という形となる。
'='を使っているのは、
「add x yはx + yに置き換えられる」ということを示している。
たとえば、プログラム中でadd 3 8とあれば3 + 8に置き換えられる。

### 関数の適用

関数addに実引数3, 8を与えるには以下のようにする。

    add 3 8

[関数名] [実引数1] [実引数2] ...という形となる。
add (3, 8)のようにはしない。
関数名のあとに空白でくぎった実引数を並べれば良い。
この記法の合理性は講義が進むにつれて明らかになる。

### エディタについて

#### 今回用意したエディタ

今回、用意したエディタは以下の三種類。

    nano, vim, Emacs

vimやEmacsを使う人は「いつも通りに」編集してほしい。
著者はvim使いなのでvimについては多少は教えられるが、Emacsについてはわからない。

これら三種類のどれも使ったことがないという人は、
とりあえずnanoを使っておこう。

#### nanoエディタ

vimやEmacsを使う人は以下は気にしないで良い。

nanoは非常にシンプルなエディタである。
foo.txtを編集して練習してみよう。

    % cd ~/lectures/lecture01/
    % nano -w foo.txt

wオプションは自動的な改行の挿入を抑制する。

適当に入力してみよう。例えば、

    foo bar baz

保存するにはCtrl-Oとする。
すると、保存するファイル名の確認のプロンプトが出るので、
そのままリターンを入力する。

終了するにはCtrl-Xとする。

### やってみよう

ghciの対話環境内でも関数定義は可能。
しかし、関数が長くなってくると大変なので、
別ファイルで関数を定義して、
対話環境でそれを読み込んで使うことにする。

例題として以下の関数を作ろう。
「身長と体重を入力するとBMIを返す」関数bmi。
BMIは以下の式で計算できる。

    BMI = [体重(kb)] / [身長(m)の2乗]

以下のコマンドでbmi.hsファイルを作ろう。

    % cd ~/lectures/lecture01
    % [エディタ] bmi.hs

[エディタ]はnano -w, vim, emacsのどれかとなる。
nanoを使う人はwオプションを忘れずにつけよう。
今後は[エディタ]と書く代わりにnano -wと書くので、
vimやemacsを使う人は各自読み換えてほしい。

bmi.hsに以下の内容を書き込もう。

    bmi h w = w / (h / 100) ^ 2

[エディタ]は終了させずに、
[エディタ]を開くのに使ったターミナル以外に、
もうひとつターミナルを開く。

ghciにこのファイルを読み込ませる。

    % cd ~/lectures/lecture01
    % ghci bmi.hs
    *Main>

プロンプトの内容が"Prelude"ではなく"*Main"になった。
この意味は後々明らかになる。

とりあえず、チェ・ホンマンのBMIを求めてみよう。

    *Main> bmi 218 164
    34.508879723928956

### まとめ

* 関数とは引数を取り返り値を返すもの
* Haskellでは以下のように定義する
    - [関数名] [仮引数1] [仮引数2] ... = [表現]
* 関数fに値xを与えることをxにfを適用する、という
* 関数適用は以下のようにする
    - [関数名] [実引数1] [実引数2]

関数の部分適用
--------------

### チェ・ホンマン激やせ

例えばチェ・ホンマンのbmiの変化を見たいと思ったとする。

    % ghci bmi.hs
    *Main> bmi 218 164
    34.508879723928956

2012年4月ごろに24kg減量したらしい。

    *Main> bmi 218 140
    29.458799764329598

### チェ・ホンマン用の関数

今後もチェホンマンのbmiを追っていきたい、と思ってください。
チェホンマン専用の関数を作ってみよう。

bmi.hsに以下を追加してみよう。

    bmiCHM w = bmi 218 w

もとのプロンプトにもどり以下を入力してみよう。

    *Main> :reload

ファイルの再読み込みができる。
エディタと対話環境を両方開いておくと便利だ。

使ってみよう。

    *Main> bmiCHM 164
    34.508879723928956
    *Main> bmiCHM 140
    29.458799764329598

### 第一引数のみ指定

bmiCHMの定義をもう一度見てみると、

    bmiCHM w = bmi 218 w

これはbmiの第一引数のみを指定しているということ。

これを以下のように書くことができる。

    bmiCHM = bmi 218

### 部分適用

関数の引数のうち一部だけを「適用」しているので、
bmi 218のような形を「部分適用」と呼ぶ。
この形には指定されていない引数がひとつ残っている。
bmi 218はこの残りの引数を取って値を返す関数となる。
よって(bmi 218) 164のように引数を与えることができる。

今までは、関数に2つの引数を与えているものとして扱ってきたが、
本当のところbmi 218 164は(bmi 218) 164の括弧の省略した形である。
厳密に言えば、Haskellに2引数関数というものはない。

関数bmiは「引数を与えると『引数をひとつ取る関数』を返す関数」なのだ。

括弧を省略しない形を試してみよう。

    *Main> (bmi 218) 164
    34.508879723928956

### まとめ

* Haskellには2引数関数はない
* 2引数関数のように見えるものは
    - 引数を取って「ひとつ引数を取る関数」を返す関数
* 関数適用が左結合なので括弧が省略できる
* 具体例を挙げれば
    - bmi 218 164は(bmi 218) 164と解釈される
* 「型」について学ぶとより明らかになる

関数リテラル
------------

### 関数リテラルの記法

たとえば数を利用するときにはいちいち名前をつける必要はない。
2とか3とかそのまま書けばいい。
この2とか3とかの「自身を表す値」をリテラルと呼ぶ。

関数について考えてみよう。
「引数xに対してxのx乗を返す関数」を作りたい場合、
今までのやりかただと、
これをそのまま書くことはできない。
必ず名前をつける必要があった。

    fun x = x ^ x

これをtest.hsに書き込んで試してみよう。

    *Main> :load "test.hs"
    *Main> fun 8
    16777216

たとえばこのfunを一回しか使わない場合、いちいち名前をつける必要はない。
関数リテラルの記法を用うと無名関数が作れる。

試してみよう。

    *Main> (\x -> x ^ x) 8
    16777216

以下のような形となる。

    \[仮引数] -> [表現]

### 関数定義との関係

関数bmiを2引数関数としてではなく
「関数を返す関数」であることを意識して定義すると以下のようになる。

    bmi h = \w -> w / (h / 100) ^ 2

さらにリテラルで関数を作ってそれで変数を束縛していることを考えると、

    bmi = \h -> \w -> w / (h / 100) ^ 2

リテラルを使わない関数の定義は実は2つのことを同時にしていた。

1. 関数の作成
2. 作成した関数での変数の束縛

ちなみに、手続き型言語での「[値]を[変数]に代入する」を、
関数型言語では「[値]で[変数]を束縛する」と言う。

### 複数の引数をとる関数リテラル

複数の引数をとる関数リテラルには省略記法がある。

    \h -> \w -> w / (h / 100) ^ 2
    → \h w -> w / (h / 100) ^ 2

一般的に書くと以下のようになる。

    \[引数1] -> \[引数2] -> ... -> [表現]
    → \[引数1] [引数2] ... -> [表現]

### まとめ

* 関数リテラルの記法を使うと無名関数を書くことができる
    - \[引数1] [引数2] ... -> [表現]
* 普通の関数定義は構文糖と考えることができる
* 以下の2つは同じものになる
    - [関数名] [引数1] [引数2] ... = [表現]
    - [関数名] = \[引数1] [引数2] ... -> [表現]

高階関数
--------

### 高階関数とは

以下のどちらかを満たす関数を高階関数と呼ぶ

* 引数として関数をとる
* 返り値として関数を返す

高階関数を使うと「くりかえし」等の「構造」を関数で表現できる。
つまり、他の多くの言語では用意しなければならない「構文」を関数として定義できる。
単なる関数なので、自分用にカスタマイズした「構造」を作ることも容易である。

Haskellでは複数の引数をとる関数はすべて高階関数となるが、
そのような関数を「高階関数」として見るか、
複数の引数をとる関数として見るかの使いわけをすると理解しやすくなる。

### 高階関数の例

与えられた関数を与えられた値に2回適用する関数を使ってみる。
higher.hsに以下を書き込もう。

    twice f x = f (f x)

試してみよう。

    *Main> :load higher.hs
    *Main> twice (\x -> x * (x + 1)) 2
    42

twiceは第一引数が関数なので高階関数である。
「関数を2回適用する」という「構造」を抽出したと言える。

### まとめ

* 引数または返り値が関数である関数を高階関数と呼ぶ
* 返り値が関数である関数は複数の引数をとる関数と同じこと
    - 場面に応じて両方の見方を使いわけると良い
* 高階関数を使うとプログラムの流れの「構造」を関数で表せる

演算子
------

### 演算子と関数

Haskellの演算子は関数と同じものである。記法の違い以外の差はない。
3 + 8は(+)という関数に引数として3と8を与えたということ。
記法上も、演算子は()でかこえば普通の関数として扱うことができる。

    *Main> 3 + 8
    11
    *Main> (+) 3 8
    11

逆に関数は`(バッククォート)でかこうと演算子となる。

    *Main> :load bmi.hs
    *Main> 218 `bmi` 164
    34.508879723928956

### 演算子の部分適用

関数と同様に演算子にも部分適用が可能である。
第1引数と第2引数のどちらを部分適用しても良い。

    *Main> (3 +) 8
    11
    *Main> (+ 8) 3
    11

関数由来の演算子についても同じことができる。

    *Main> (218 `bmi`) 164
    34.508879723928956
    *Main> (`bmi` 164) 218
    34.508879723928956

### 演算子の定義

演算子も関数と同様に自分で定義できる。演算子に使える記号には、
アスキーの範囲では、以下のものがある。

    !#$%&*+./<=>?@\^|-~

ただし、':'から始まる演算子は普通の演算子として定義することはできない。

定義のしかたは以下のようになる。

    y ./^ x = sqrt (x ^ 2 + y ^ 2)

関数と同じ形での定義も可能だ。

    (./^) y x = sqrt (x ^ 2 + y ^ 2)

逆に関数を演算子と同じ形で定義することもできる。

    h `bmi` w = w / (h / 100) ^ 2

便利な演算子
------------

### ドット演算子

以下のような形の定義はしばしば出てくる。

    fun x = f (g x)

xにgを適用して、その結果にfを適用するということ。
これを「関数合成」と呼ぶ。

さらに長くなってこんなふうになることもある。

    fun2 x = f1 (f2 (f3 (f4 (f5 (f6 (f7 x))))))

ドット演算子を使えばそれぞれ以下のように書ける。

    fun = f . g
    fun2 = f1 . f2 . f3 . f4 . f5 . f6 . f7

この形で書くと関数合成という考えかたを直接的に表現できる。

### $演算子

以下のような演算子も用意されている。

    f $ x = f x

右辺の値に左辺の関数を適用するという演算子である。
つまりf $ xとf xとは同じものである。
一見意味のない演算子のように見える。
しかし、いくつかの用途があり、そのうちのひとつに「()の省略」がある。
($)は結合力が低く右結合するように定義されているので、以下を

    f (g (h (i (j (k x)))))

以下のように書き換えられる。

    f $ g $ h $ i $ j $ k x

この形にすると「fの後に来るのは必ずひとまとまりとなり、
それはfの唯一の引数となる」ことが明らかとなり、
コードが読みやすくなる。

まとめ
------

* 関数定義: [関数名] [仮引数] [仮引数] ... = [表現]
* 関数適用: [関数名] [実引数] [実引数] ...
* 複数の引数をとる関数は実は「関数を返す関数」である
* 関数リテラル: \[仮引数1] [仮引数2] ... -> [表現]
* 引数か返り値が関数であるような関数を高階関数と呼ぶ
* 演算子と関数は()と``で相互に変換可能
* 演算子も関数も部分適用が可能
* 便利な演算子(.)と($)が用意されている
