第15回 関数の変換
=================

はじめに
--------

単純な関数を高階関数に変えたり、引数を追加したり、減らしたり、
いろいろな変換を関数に対してすることができる。
型と定義とを見くらべながらやっていく。
次回「モナド」を学ぶときに、この操作を使うとわかりやすい。

関数に対するいろいろな変換を見ていこう。

(->)は右結合
------------

### どういうことか

関数に対する変換を見ていくわけだが、ひとつ頭に置いておくと良いことがある。
それは、関数の型を作るときに使われる(->)が右結合であるということだ。
以下のふたつの定義が同じであるということである。

    a -> b -> c
    a -> (b -> c)

これは以下のふたつが同じであるということだ。

* 引数を2つとる関数
* 引数を1つとり「引数を1つとる関数」を返す関数

### 関数curryの2つの見方

関数curryを例にして見てみよう。

    curry :: ((a, b) -> c) -> (a -> b -> c)
    curry f = \x y -> f (x, y)

これは「2要素タプルをとる関数を、引数を2つとる関数に変換する関数」である。

まったく同じことを以下のようにも書ける。

    curry :: ((a, b) -> c) -> a -> b -> c
    curry f x y = f (x, y)

同じことだが、この表記だと
「タプルをとる関数の他に引数を2つとり、
それらをタプルにまとめたうえで第1引数の関数を適用する関数」となる。

ユニット型()
------------

### ユニット型とは

ユニット型とは、
()という値をひとつだけ持つ()という型のことである。
()以外の値は持たない。
Bool型はFalseとTrueの2つの値を取るので、
()型はBool型以上に単純な型と言える。

この値はあってもなくても変わらない。
よって以下はどれも同じものと考えることができる。

ここで言う「同じもの」とは情報量が変わらないということを指す。

    a
    () -> a
    (a, ())

### ユニット型を引数にとる関数

以下の2つが同じものであることを確認する。
追加の情報なしに互いに相手を導出できれば良い。

    val :: a
    fun :: () -> a

funをvalを使って定義する。

    fun () = val

valをfunを使って定義する。

    val = fun ()

追加の情報なしで、互いに相手を定義できるのでvalとfunは同じものと言える。

### ユニット型を要素とするタプル

以下の2つについても確認しておく。

    val :: a
    tup :: (a, ())

tupをvalを使って定義してみる。

    tup = (val, ())

valをtupを使って定義してみる。

    val = fst tup

よってaと(a, ())は同じものである。

### まとめ

Bool型はTrueかFalseのどちらかなので、
どちらかがわかれば情報が増えることになる。
()型には()しかないので、
「()だ!」と言っても情報は増えない。
よって()型は、引数の位置に出てきても、
タプルのなかに出てきても取り除くことができる。

型同士が「同じ」ものであることを、追加の情報なしに、
互いに相手を定義することで確かめられる。

単純な値と高階関数
------------------

### 導入

たとえば以下の関数について考えてみよう。

    eight :: (Int -> b) -> b
    eight f = f 8

lectures/lecture15ディレクトリを作成し、transFuns.hsに書きこむ。

eightは第1引数の関数に8を適用する関数である。
しかし、これは単なる8とほとんど同じものである。

試してみる。

    % ghci transFuns.hs
    *Main> eight (+ 5)
    8
    *Main> eight even
    True
    *Main> eight id
    8

### 一般化

すべての値がeightと同じような形に変換できる。
もとの値をxとし、型をaとすると

    x :: a
    funX :: (a -> b) -> b
    funX f = f x

### 単純な値から関数への変換

この変換を行う関数を作ってみる。

    valToFun :: a -> ((a -> b) -> b)
    valToFun x = \f -> f x

同じことを以下のようにも書ける。

    valToFun :: a -> (a -> b) -> b
    valToFun x f = f x

好きなほうの定義をtransFuns.hsに書きこむ。

試してみる。

    *Main> :reload
    *Main> let three = valToFun 3
    *Main> three (+ 7)
    10
    *Main> three even
    False
    *Main> :load + Data.Char
    *Main Data.Char> let c = valToFun 'c'
    *Main Data.Char> c isLower
    True

### 関数から単純な値への変換

逆の方向の変換も可能である。
eight idで見たように引数としてid与えてやれば良い。

    fun :: (a -> b) -> b
    val :: a
    val = fun id

### まとめ

以下の2つの型は同じものと考えられる。

    a
    (a -> b) -> b

前者を後者の形式に変換する関数valToFunを定義した。

    valToFun :: a -> (a -> b) -> b
    valToFun x f = f x

逆方向の変換は関数形式のほうに引数としてidを与えれば良い。
つまり、以下のような形の関数は、より単純な値に置き換えられる。

    (Int -> b) -> b
    (Char -> b) -> b
    ([Int] -> b) -> b
    ((Int -> Char) -> b) -> b
    ...

1引数関数と高階関数
-------------------

2引数関数と高階関数
-------------------

まとめ
------
