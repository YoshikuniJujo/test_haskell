第15回 関数の変換
=================

はじめに
--------

単純な関数を高階関数に変えたり、引数を追加したり、減らしたり、
いろいろな変換を関数に対してすることができる。
型と定義とを見くらべながらやっていく。
次回「モナド」を学ぶときに、この操作を使うとわかりやすい。

関数に対するいろいろな変換を見ていこう。

(->)は右結合
------------

### どういうことか

関数に対する変換を見ていくわけだが、ひとつ頭に置いておくと良いことがある。
それは、関数の型を作るときに使われる(->)が右結合であるということだ。
以下のふたつの定義が同じであるということである。

    a -> b -> c
    a -> (b -> c)

これは以下のふたつが同じであるということだ。

* 引数を2つとる関数
* 引数を1つとり「引数を1つとる関数」を返す関数

### 関数curryの2つの見方

関数curryを例にして見てみよう。

    curry :: ((a, b) -> c) -> (a -> b -> c)
    curry f = \x y -> f (x, y)

これは「2要素タプルをとる関数を、引数を2つとる関数に変換する関数」である。

まったく同じことを以下のようにも書ける。

    curry :: ((a, b) -> c) -> a -> b -> c
    curry f x y = f (x, y)

同じことだが、この表記だと
「タプルをとる関数の他に引数を2つとり、
それらをタプルにまとめたうえで第1引数の関数を適用する関数」となる。

ユニット型()
------------

### ユニット型とは

ユニット型とは、
()という値をひとつだけ持つ()という型のことである。
()以外の値は持たない。
Bool型はFalseとTrueの2つの値を取るので、
()型はBool型以上に単純な型と言える。

この値はあってもなくても変わらない。
よって以下はどれも同じものと考えることができる。

ここで言う「同じもの」とは情報量が変わらないということを指す。

    a
    () -> a
    (a, ())

### ユニット型を引数にとる関数

以下の2つが同じものであることを確認する。
追加の情報なしに互いに相手を導出できれば良い。

    val :: a
    fun :: () -> a

funをvalを使って定義する。

    fun () = val

valをfunを使って定義する。

    val = fun ()

追加の情報なしで、互いに相手を定義できるのでvalとfunは同じものと言える。

### ユニット型を要素とするタプル

以下の2つについても確認しておく。

    val :: a
    tup :: (a, ())

tupをvalを使って定義してみる。

    tup = (val, ())

valをtupを使って定義してみる。

    val = fst tup

よってaと(a, ())は同じものである。

### まとめ

Bool型はTrueかFalseのどちらかなので、
どちらかがわかれば情報が増えることになる。
()型には()しかないので、
「()だ!」と言っても情報は増えない。
よって()型は、引数の位置に出てきても、
タプルのなかに出てきても取り除くことができる。

型同士が「同じ」ものであることを、追加の情報なしに、
互いに相手を定義することで確かめられる。

単純な値と関数
--------------

### 導入

たとえば以下の関数について考えてみよう。

    eight :: (Int -> b) -> b
    eight f = f 8

lectures/lecture15ディレクトリを作成し、transFuns.hsに書きこむ。

eightは第1引数の関数に8を適用する関数である。
しかし、これは単なる8とほとんど同じものである。

試してみる。

    % ghci transFuns.hs
    *Main> eight (+ 5)
    8
    *Main> eight even
    True
    *Main> eight id
    8

### 一般化

すべての値がeightと同じような形に変換できる。
もとの値をxとし、型をaとすると

    x :: a
    funX :: (a -> b) -> b
    funX f = f x

### 単純な値から関数への変換

この変換を行う関数を作ってみる。

    valToFun :: a -> ((a -> b) -> b)
    valToFun x = \f -> f x

同じことを以下のようにも書ける。

    valToFun :: a -> (a -> b) -> b
    valToFun x f = f x

好きなほうの定義をtransFuns.hsに書きこむ。

試してみる。

    *Main> :reload
    *Main> let three = valToFun 3
    *Main> three (+ 7)
    10
    *Main> three even
    False
    *Main> :load + Data.Char
    *Main Data.Char> let c = valToFun 'c'
    *Main Data.Char> c isLower
    True

### 関数から単純な値への変換

逆の方向の変換も可能である。
eight idで見たように引数としてid与えてやれば良い。

    fun :: (a -> b) -> b
    val :: a
    val = fun id

### まとめ

以下の2つの型は同じものと考えられる。

    a
    (a -> b) -> b

前者を後者の形式に変換する関数valToFunを定義した。

    valToFun :: a -> (a -> b) -> b
    valToFun x f = f x

逆方向の変換は関数形式のほうに引数としてidを与えれば良い。
つまり、以下のような形の関数は、より単純な値に置き換えられる。

    (Int -> b) -> b
    (Char -> b) -> b
    ([Int] -> b) -> b
    ((Int -> Char) -> b) -> b
    ...

1引数関数と高階関数
-------------------

### 導入

以下の関数を見てみよう。

    myChr :: (a -> Int) -> (a -> Char)
    myChr f = \x -> chr $ f x

transFuns.hsに書きこむ。
Data.Charモジュールのchrを使っているので先頭に以下を追加する。

    import Data.Char (chr, ord)

myChrは「関数fを引数にとり、
『引数にfを適用しchrを適用する関数」を返す関数」である。

試してみる。

    *Main> :reload
    *Main> myChr (* 2) 55
    'n'
    *Main> myChr ord 'j'
    'j'
    *Main> (chr . (* 2)) 55
    'n'
    *Main> (chr . ord) 'j'
    'j'

myChrの定義は以下のように書き換えられる。

       myChar f = \x -> chr $ f x
    -> myChar f = chr . f
    -> myChar = (chr .)

myCharは「関数chrと他の関数とを合成する関数」と言える。

### 一般化

より一般的にすると

    fun :: b -> c
    fun' :: (a -> b) -> (a -> c)
    fun' = (fun .)

### 1引数関数から高階関数へ

#### 関数addArg

(b -> c)の形から(a -> b) -> (a -> c)の形にする。
つまり「引数と返り値の両方に同じ引数をひとつ追加する」ということ。

これをする関数を作る。

    addArg :: (b -> c) -> ((a -> b) -> (a -> c))
    addArg f = \g -> (\x -> f $ g x)

これを変換していくと最終的には以下のようになる。

    addArg :: (b -> c) -> (a -> b) -> (a -> c)
    addArg = (.)

つまり、関数addArgは単なる関数合成演算子と同じ。

#### 関数(.)の2つの見かた

fとgの合成関数f . gは「gを適用した結果にfを適用」する。

2引数関数として見ると(.)は関数合成する関数である。

    (.) :: (b -> c) -> (a -> b) -> (a -> c)

見かたを変えて1引数関数として見ると

    (.) :: (b -> c) -> ((a -> b) -> (a -> c))

「引数と返り値の両方に引数を1つ追加する関数」と読める。

### 高階関数から1引数関数へ

逆方向の変換をする関数を作成する。

    rmArg :: ((a -> b) -> (a -> c)) -> (b -> c)
    rmArg f = \x -> f (const x) undefined

これを型のレベルで解説する。

    x :: b
    f :: (a -> b) -> (a -> c)

    const x :: a -> b
    f (const x) :: a -> c
    f (const x) undefined :: c
    \x -> f (const x) undefined :: b -> c

    rmArg f :: b -> c
    rmArg :: ((a -> b) -> (a -> c)) -> (b -> c)

### まとめ

以下の2つの関数はほとんど同じものと考えることができる。

    fun :: b -> c
    fun' :: (a -> b) -> (a -> c)
    fun' = (fun .)

「引数と返り値の両方に1つ引数を追加する」変換ができる。
その変換と、逆の変換のそれぞれの変換を行う関数addArg, rmArgを定義した。

addArgは関数合成(.)と同じものとなる。

以下の形の型を見たら、より単純な関数に置き換えられる。

    (a -> Int) -> (a -> Char)
    (a -> [Int]) -> (a -> [Bool])
    (a -> Int -> Char) -> (a -> Bool)

2引数関数と高階関数
-------------------

### 導入

以下の関数を考える。

    myAdd :: (a -> Int) -> Int -> (a -> Int)
    myAdd f y = \x -> f x + y

関数fと整数yを取り
「引数xに関数fを適用した結果に整数yを足す関数」を返す。

transFuns.hsに書き込み、試してみる。

    *Main> :reload
    *Main> (myAdd (* 2) 3) 8
    19

### 一般化

より一般的には以下のようになる。

    fun :: b -> c -> d
    fun' :: (a -> b) -> c -> (a -> d)
    fun' f y = \x -> fun (f x) y

「第1引数と返り値に引数を1つ追加する」変換である。

### 2引数関数から高階関数へ

    addArg2 :: (b -> c -> d) -> (a -> b) -> c -> (a -> d)
    addArg2 fun f y = \x -> fun (f x) y

これをポイントフリースタイルにすると

    addArg2 = (. flip (.)) . flip (.) . flip

flipや(.)は引数の位置を変える等のある意味では「中身のない関数」なので、
addArg2による変換には追加の情報は必要ないことがわかる。

ポイントフリースタイルへの変換は手順を踏めば誰にでもできる。
今はとくに気にせずに「addArg2はflipと(.)だけで書き直せる」とだけ
知っておけばいい。

### 高階関数から2引数関数へ

逆方向の変換は以下のようになる。

    rmArg2 :: ((a -> b) -> c -> (a -> d)) -> (b -> c -> d)
    rmArg2 f = \x y -> f (const x) y undefined

型レベルでの解説をする。

    x :: b
    y :: c
    f :: ((a -> b) -> c -> (a -> d))

    const x :: a -> b
    f (const x) :: c -> (a -> d)
    f (const x) y :: a -> d
    f (const x) y undefined :: d
    \x y -> f (const x) y undefined :: b -> c -> d

    rmArg2 f :: b -> c -> d
    rmArg2 :: ((a -> b) -> c -> (a -> d)) -> (b -> c -> d)

### まとめ

以下の2つの関数はほぼ同じである。

    fun :: b -> c -> d
    fun' :: (a -> b) -> c -> (a -> d)
    fun' f y = \x -> fun (f x) y

第1引数と返り値に引数を1つ追加する関数と、
逆向きの関数とを定義した。

    addArg2 fun f y = \x -> fun (f x) y
    rmArg2 f = \x y -> f (const x) y undefined

以下のような型を見たらより簡単な型に変換できる。

    (a -> Char) -> Int -> (a -> Bool)
    (a -> [Bool]) -> [Char] -> (a -> [Int])
    (a -> Char) -> (Double -> Bool) -> (a -> Int)
    ...

まとめ
------

意味をほどんど変えない、関数の変換を見てきた。
これらは片方が存在すればもう一方を導ける。
複雑なほうの型の関数を作る場合、
より簡単なほうの型の関数から変換するほうが、
コードがすっきりするだろう。

以下の変換を次回の「モナド」の回で使う。

       b -> c -> d
    => (a -> b) -> c -> (a -> d)

これは後者の形の関数が必要になった場合、
前者の形の関数から導出できるということである。

やや不正確だが
「引数と結果の関数に引数として同じ型変数がある場合、
それを削除できる」と考えておこう。
