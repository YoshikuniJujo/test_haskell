第9回 リストの再帰的定義
========================

はじめに
--------

前回は引数をとってリストを作成する関数を見た。
今回は引数無しで直接無限リストを作成する方法を見る。

フィボナッチ数列
----------------

### フィボナッチ数列とは

次の数が前の2項の和となる数列である。

    0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89 ...

以下のように計算される。

* 0, 1のつぎは0 + 1で1
* 1, 1のつぎは1 + 1で2
* 1, 2のつぎは1 + 2で3
* 2, 3のつぎは2 + 3で5
* 3, 5のつぎは3 + 5で8
* 5, 8のつぎは5 + 8で13
* 8, 13のつぎは8 + 13で21

### アルゴリズム

フィボナッチ数列の最初の要素を落としたtfibsを考えると、
以下の式が成り立つ。

       fibs = __ __ 0, 1, 1, 2, 3, _5, _8, 13 ...
    + tfibs = __ __ 1, 1, 2, 3, 5, _8, 13, 21 ...
    _________________________________________________
       fibs = 0, 1, 1, 2, 3, 5, 8, 13, 21, 34 ...

つまり、fibsは0, 1のあとにfibsとtfibsのそれぞれの要素を足したもの、となる。

### 新たに必要になる構文

#### @(as)パターン

以下のような例を考える。

    dupHead (x : xs) = x : (x : xs)

この例ではパターンマッチでリストを頭部(x)と尾部(xs)に分割したうえで、
再度結合(x : xs)している。

ここの重複をなくすためには、全体を変数へ束縛すると同時に、
さらに細かいパターンマッチを行えれば良い。

@(as)パターンでこれが実現できる。

    dupHead xa@(x : xs) = x : xa

### 新たに必要になる関数

#### 関数zipWith

2つのリストの各要素を与えられた演算子で結合した値を要素とするリストを作りたい。

そのための関数が用意されている。

    zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]

試してみる。

    *Main> zipWith (*) [1, 2, 3] [4, 5, 6]
    [4, 10, 18]

### フィボナッチ数列の定義

fibsほtfibsがすでにあると仮定するとfibsは以下のように定義できる。

    fibs = 0 : 1 : zipWith (+) fibs tfibs

fibsはこれで定義できるがtfibsがまだ定義できていない。

tfibsはfibsのtail部分なので

    fibs@(_ : tfibs) = 0 : 1 : zipWith (+) fibs tfibs

### 試してみる

lectures/lecture09を作成しそこに移動し、fib.hsに以下を書き込もう。

    fibs, tfibs :: [Integer]
    fibs@(_ : tfibs) = 0 : 1 : zipWith (+) fibs tfibs

試してみる。

    % ghci fib.hs
    *Main> take 30 fibs
    [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,
    4181,6765,10946,17711,28657,46368,75025,121393,196418,317811,
    514229]

まとめ
------

リスト自体を再帰的に定義することができることを示すために、
フィボナッチ数列の例を見た。
