第10回 演習(2日目)
==================

はじめに
--------

Haskellにおいてリストは再要なデータ構造である。
リストを扱う多くの関数が用意されていて、
それらの関数は再帰的に定義される。
そのような関数の一部について使いかたや作られかたを見た。

演習ではいろいろな再帰関数を定義していく。
とくに、リストを扱う関数を複数のやりかたで定義してみる。

新たに必要になる知識
--------------------

### Prelude

明示的にimportしなくても使える関数や変数等がある。
それらの名前はPreludeというモジュールからexportされている。

ghciを引数無しで立ち上げたときに表示されるプロンプトは
Preludeモジュールのなかにいるということを示している。

Preludeはどのモジュールにも暗黙にimportされるので、
同じ名前の別の関数を使いたいときに困ってしまう。
そのようなときは以下のように明示的にimportすることになる。

    import Prelude hiding ([再定義したい名前の列挙])

今回はPreludeの関数を再定義していくので、以下のようにする。

    import Prelude hiding (map, filter ...)

### コメント

今回は同じ関数にいろいろな定義を与えるので、
古いほうの定義をコメントアウトしたいことがある。
コメントは以下の2つの形式が使える。

* '--'を行頭につける
* '{-'と'-}'でかこう

### 名前のなかの'(アポストロフィ)

または、同じものの別の表現という意味でmap'やmap''のようにしても良い。
'(アポストロフィ)は名前の一部として扱われる。

関数exp2
--------

### 問題定義

2のn乗を求める関数exp2を求める。
もちろん(^)を使えば簡単だが、ここでは(^)を使わないこととする。

### 演習

* 演習10-1. Intを扱うとして型を求めよ(30秒)
* 演習10-2. 再帰を直接使って定義せよ(1分)

### 負の値の扱い

解答として示した関数には実は問題がある。
exp2に負の値を与えた場合に無限ループになってしまう
(より正確に言うとInt型の場合には無限ループにはならない)。

今までの講義のなかでは簡単のため、同種の問題のある関数を作ってきた。
ここで、この問題の解決策について触れておこう。
この問題を解決する3つの方法がある。

1. Maybe型を使う
2. 明示的なエラーを返す
3. 適当な値を返す

安全性という点では、1が最も良い方法で3が最も悪い方法と言える。

#### Maybe型を使う

Maybe型を使った定義は以下のようになる。

    exp2 :: Int -> Maybe Int
    exp2 n | n < 0 = Nothing
    exp2 0 = Just 1
    exp2 n = case exp2 (n - 1) of
        Just r -> Just $ 2 * r
        _ -> Nothing

#### 明示的なエラーを返す

明示的なエラーを返す方法は以下のようになる。

    exp2 :: Int -> Int
    exp2 n | n < 0 = error "Negative exponent"
    exp2 0 = 1
    exp2 n = 2 * exp2 (n - 1)

#### 適当な値を返す

適当な値を返す方法は以下のようになる。

    exp2 :: Int -> Int
    exp2 n | n <= 0 = 1
    exp2 n = 2 * exp2 (n - 1)

#### 型による解決

そもそも負の値を含まない型を使うという方法もある。

    exp2 :: Word -> Word
    exp2 = (ここは演習10-2の解と同じ)

### 無限リストを使った解

関数exp2を無限リストを使って定義することもできる。
以下のようなリストがあれば

    exp2s :: [Int]
    exp2s = [1, 2, 4, 8, 16, 32 ...]

exp2は以下のように定義することができる。

    exp2 :: Int -> Int
    exp2 n = exp2s !! n

* 演習10-3. 無限リストexp2sを定義せよ
    + ヒント: map, zipWithまたはiterateが使える(1分)

関数oddSum
----------

関数oddSumはリストの要素のうちの奇数の総和を返す。

* 演習10-4. sum, filterを使ってoddSumを定義せよ(1分)
* 演習10-5. 再帰的定義を直接使ってoddSumを定義せよ(1分)

関数map
-------

### 再帰的定義

* 演習10-6. 再帰を直接使ってmapを定義せよ(2分)

### リストを扱う関数としての関数map

* 演習10-7. foldrを使ってmapを定義せよ(2分)

### リストを返す関数としての関数map

* 演習10-8. unfoldrを使ってmapを定義せよ(2分)

関数filter
----------

* 演習10-9. 再帰を直接使ってfilterを定義せよ(1分)
* 演習10-10. foldrを使ってfilterを定義せよ(2分)

関数reverse
-----------

### 問題定義

関数reverseはリストを逆順にする。

### アルゴリズム

まずは、再帰を直接使ってreverseを定義する。
これは反復的処理を使うとスマートに定義できる。
再帰的定義によって反復的処理が記述できることを思い出そう。

リストの頭から要素を取っていき次々とリストの頭に足していく。
トランプの山を一枚ずつ別の山に移動していくことをイメージする。
結果としてできる山ではカードが逆順になっているはずだ。

### 蓄積変数

反復的処理には蓄積変数が必要となる。
これはreverse自体の引数(もとのリスト)とは別に用意してやる必要がある。
そのために、reverseから使用する別の関数reverseIterを作る。

その関数に蓄積変数の初期値を与えることでreverseを定義することができる。
蓄積変数はトランプのたとえで言えば、「別の山」ということになる。
トランプの移動のときに「別の山」ははじめは空なので、
蓄積変数の初期値は空リストということになる。

    reverse = reverseIter []

### 関数reverseIter

* 演習10-11. reverseIterの型を求めよ(1分)
* 演習10-12. 再帰を直接使ってreverseIterを定義せよ(1分)
* 演習10-13. foldlを使ってreverseを定義せよ(1分)

関数zip
-------

関数unzip
---------

関数zipWith
-----------
