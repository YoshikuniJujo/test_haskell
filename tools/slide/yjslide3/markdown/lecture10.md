第10回 演習(2日目)
==================

はじめに
--------

Haskellにおいてリストは再要なデータ構造である。
リストを扱う多くの関数が用意されていて、
それらの関数は再帰的に定義される。
そのような関数の一部について使いかたや作られかたを見た。

演習ではいろいろな再帰関数を定義していく。
とくに、リストを扱う関数を複数のやりかたで定義してみる。

新たに必要になる知識
--------------------

### Prelude

明示的にimportしなくても使える関数や変数等がある。
それらの名前はPreludeというモジュールからexportされている。

ghciを引数無しで立ち上げたときに表示されるプロンプトは
Preludeモジュールのなかにいるということを示している。

Preludeはどのモジュールにも暗黙にimportされるので、
同じ名前の別の関数を使いたいときに困ってしまう。
そのようなときは以下のように明示的にimportすることになる。

    import Prelude hiding ([再定義したい名前の列挙])

今回はPreludeの関数を再定義していくので、以下のようにする。

    import Prelude hiding (map, filter ...)

### コメント

今回は同じ関数にいろいろな定義を与えるので、
古いほうの定義をコメントアウトしたいことがある。
コメントは以下の2つの形式が使える。

* '--'を行頭につける
* '{-'と'-}'でかこう

### 名前のなかの'(アポストロフィ)

または、同じものの別の表現という意味でmap'やmap''のようにしても良い。
'(アポストロフィ)は名前の一部として扱われる。

関数exp2
--------

### 問題定義

2のn乗を求める関数exp2を求める。
もちろん(^)を使えば簡単だが、ここでは(^)を使わないこととする。

### 演習

* 演習10-1. Intを扱うとして型を求めよ(30秒)
* 演習10-2. 再帰を直接使って定義せよ(1分)

### 負の値の扱い

解答として示した関数には実は問題がある。
exp2に負の値を与えた場合に無限ループになってしまう
(より正確に言うとInt型の場合には無限ループにはならない)。

今までの講義のなかでは簡単のため、同種の問題のある関数を作ってきた。
ここで、この問題の解決策について触れておこう。
この問題を解決する3つの方法がある。

1. Maybe型を使う
2. 明示的なエラーを返す
3. 適当な値を返す

安全性という点では、1が最も良い方法で3が最も悪い方法と言える。

#### Maybe型を使う

Maybe型を使った定義は以下のようになる。

    exp2 :: Int -> Maybe Int
    exp2 n | n < 0 = Nothing
    exp2 0 = Just 1
    exp2 n = case exp2 (n - 1) of
        Just r -> Just $ 2 * r
        _ -> Nothing

#### 明示的なエラーを返す

明示的なエラーを返す方法は以下のようになる。

    exp2 :: Int -> Int
    exp2 n | n < 0 = error "Negative exponent"
    exp2 0 = 1
    exp2 n = 2 * exp2 (n - 1)

#### 適当な値を返す

適当な値を返す方法は以下のようになる。

    exp2 :: Int -> Int
    exp2 n | n <= 0 = 1
    exp2 n = 2 * exp2 (n - 1)

#### 型による解決

そもそも負の値を含まない型を使うという方法もある。

    exp2 :: Word -> Word
    exp2 = (ここは演習10-2の解と同じ)

### 無限リストを使った解

関数exp2を無限リストを使って定義することもできる。
以下のようなリストがあれば

    exp2s :: [Int]
    exp2s = [1, 2, 4, 8, 16, 32 ...]

exp2は以下のように定義することができる。

    exp2 :: Int -> Int
    exp2 n = exp2s !! n

* 演習10-3. 無限リストexp2sを定義せよ
    + ヒント: map, zipWithまたはiterateが使える(1分)
