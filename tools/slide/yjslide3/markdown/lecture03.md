第3回 タプル
============

はじめに
--------

複数の値をまとめた構造をひとつの値として扱える。
その構造をタプルと呼ぶ。
タプルを引数として使う場合にはパターンマッチが利用できる。

Haskellにおける「複数の引数をとる関数」は「関数を返す関数」だが、
その「複数の引数」をタプルとしてまとめられる。
その逆もでき、それを「カリー化」と呼ぶ。

例題:原点からの距離
-------------------

### 距離を求める関数

直交座標上の原点からの距離を求める関数を考える。

lectures/lecture03を作成しそこに移動。
coordinate.hsを作成し以下を書き込もう。

    dist0 :: Double -> Double -> Double
    dist0 x y = sqrt $ x ^ 2 + y ^ 2

試してみる。

    % ghc coordinate.hs
    *Main> dist0 3 8
    8.54400374531753
    *Main> dist0 3 4
    5.0

### 点の表現

#### 別々の変数として表現

点のx座標上の位置とy座標上の位置とを保存しておいてその点について計算する。

coordinate.hsに以下を書き込もう。

    px, py :: Double
    px = 3
    py = 8

試してみる。

    *Main> :reload
    *Main> dist0 px py
    8.54400374531753

#### 点を1つの構造として表現

px, pyというように独立したふたつの数ではなくひとつの構造として表したい。
このようなときにタプルが使える。

点pをタプルを使って表してみよう。

    p :: (Double, Double)
    p = (3, 8)

より一般的に、
x1 :: T1, x2 :: T2 ...を含むタプルtの定義は以下のようになる。

    t :: (T1, T2 ...)
    t = (x1, x2 ...)

##### やってみよう

coordinate.hsにpの定義を追加する。

    p :: (Double, Double)
    p = (3, 8)

さらに、タプルを使用するdist0'を追加しよう。

    dist0' :: (Double, Double) -> Double
    dist0' (x, y) = sqrt $ x ^ 2 + y ^ 2

試してみる。

    *Main> :reload
    *Main> dist0' p
    8.54400374531753

パターンマッチ
--------------

タプルのそれぞれの要素を使う関数を書く場合、パターンマッチを使う。

### dist0'におけるパターンマッチ

(x, y)というパターンとpの値(3, 8)をマッチさせる。
それぞれ同じ位置にある構造同士をマッチさせるので、
xを3にマッチさせyを8にマッチさせる。

変数と値をマッチさせるとその変数に値が束縛される。
x, yはそれぞれ3, 8となる。
このx, yの値はそれ以降の計算で使用することができる。

### もうひとつの例

点と原点とを結ぶ直線の傾きを求める関数を書いてみよう。

x = 0の場合の扱いに注意が必要である。
この場合のふるまいとしてはいくつか考えられる。

1. 特殊な値を用意する
2. エラーとする
3. 適当な値を返す

基本的には1が最も良い(安全な)やりかたで、3が最も悪い(危険な)やりかたである。
説明の都合上、今回は3の最も悪いやりかたを採る。

coordinate.hsに以下を追加する。

    slope :: (Double, Double) -> Double
    slope (0, y) = 0
    slope (x, y) = y / x

試してみる。

    *Main> :reload
    *Main> slope (3, 8)
    2.6666666666666665
    *Main> slope (0, 5)
    0.0

### 複数のパターン

関数定義が複数ある場合、うえから順にパターンマッチしていき、
パターンマッチが成功した定義を評価する。

slope (0, 5)の場合、(0, 5)は(0, y)にマッチし、yは5に束縛される。
全体の値はslope (0, y) = 0の左辺である0になる。

slope (3, 8)の場合、(0, y)へのマッチは失敗する。
(x, y)へのマッチが成功しxは3に、yは8に束縛され、
全体の値はslope (x, y) = y / xの左辺であるy / x、
つまり8 / 3となる。

### ワイルドカード

slope (0, y)の定義のなかでyは左辺で使われていない。
このようなときyの代わりにワイルドカードが使える。

    slope (0, _) = 0

* ワイルドカードを使う利点
    1. 使わない変数のための変数名を考えなくてすむ
    2. その場所の値が使われていないことを明示できる
* ワイルドカードを使う欠点
    1. その場所の値が何なのかを示せない

欠点1を解決し、利点2を生かすために、
変数名の前に'_'(アンダースコア)をつけて、_yのようにする習慣もある。

### 関数定義

「関数」の回では関数定義を以下のように説明した。

    [関数名] [仮引数1] [仮引数2] ... = [表現]

パターンマッチを説明した今では以下のようになる。

    [関数名] [パターン1-1] [パターン1-2] ... = [表現1]
    [関数名] [パターン2-1] [パターン2-2] ... = [表現2]
    ...

変数はパターンのひとつであり、すべての値にマッチし、
マッチした結果として、その変数が値に束縛される。

### パターンとしての「数」

slope (0, y)をもう一度見てみる。
これはネストしたパターンである。
タプルというパターンのなかに、0というパターンとyというパターンがある。
パターンとしての数は値がその数と同じであるときにマッチする。

#### 例

coordinate.hsを編集していたエディタを閉じて、
編集用のコマンドプロンプトでnumber.hsを作成しよう。

    % [エディタ] number.hs

このファイルに以下を書き込もう
(Stringは文字列を表す型。詳細はリストを学んだあとで)。

    intName :: Int -> String
    intName 0 = "The name is zero."
    intName 1 = "The name is one."
    intName 2 = "The name is two."
    intName _ = "I don't know."

試してみる。

    *Main> :load number.hs
    *Main> intName 1
    "The name is one."
    *Main> intName 7
    "I don't know."

以上のように、「数」はパターンとして使うことができる。

カリー化
--------

### カリー化とは

Haskellに限らない一般的な定義としては、
複数の引数をとる関数を関数を返す関数に変えること。

### Haskellでは

Haskellではそもそも複数の引数をとる関数と関数を返す関数とは同じもの。

しかし、他の言語における「複数の引数をとる関数」は、
Haskellにおける「タプルをとる関数」に近い。
そこで、Haskellにおけるカリー化を考えると、
たとえば、dist0'からdist0への変換がカリー化となる。

    dist0' (x, y)
    -> (dist0 x) y

この逆の変換は非カリー化と呼ばれる。
2要素タプルにおけるそれぞれの変換関数が用意されている。
以下の関係が成り立つ。

    dist0 == curry dist0'
    dist0' == uncurry dist0

### やってみよう

    *Main> :load coordinate.hs
    *Main> (curry dist0') 3 8
    8.54400374531753
    *Main> (uncurry dist0) (3, 8)
    8.54400374531753

### curry, uncurry関数の定義

    curry :: ((a, b) -> c) -> (a -> b -> c)
    curry f = \x y -> f (x, y)

    uncurry :: (a -> b -> c) -> ((a, b) -> c)
    uncurry f = \(x, y) -> f x y

まとめ
------

* タプルの定義は以下のようになる
    - t :: (T1, T2 ...)
    - t = (x1, x2 ...)
* パターンマッチについて学んだ
    - (p1, p2 ...)というパターンはタプルにマッチする
    - p1, p2 ...にはそれぞれパターンがはいる
    - 変数やワイルドカードはすべてにマッチするパターン
    - 変数はマッチと同時に束縛が行われる
    - 数はそれ自身にマッチするパターン
* 以下の型の関数は相互に変換可能(カリー化、非カリー化)
    - (a, b) -> c
    - a -> b -> c
