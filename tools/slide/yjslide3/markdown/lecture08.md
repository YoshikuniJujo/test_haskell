第8回 リストを作る再帰関数
==========================

はじめに
--------

前回はリストを引数に取る再帰関数について学んだ。
今回はリストを返す再帰関数について学ぶ。

「リスト」の回でやった3段階は

1. enumerate
2. map/filter
3. accumulate

であるが、そのうちの1. enumerateにあたる部分となる。

[m .. n]
--------

### 構文糖

「リスト」の回で見た[m .. n]という構文を見る。
これは構文糖であり脱糖すると以下の関数になる。

    enumFromTo m n

### 型

この関数の型を正確に理解するためには後でやる型クラスの知識が必要になる。
今回はとりあえず以下のように理解しておこう。

    enumFromTo :: Int -> Int -> [Int]

### 定義

enumFromTo n mはmから1刻みでnまでのリストを返す関数であり、
以下のように定義できる。

    enumFromTo m n
        | m > n = []
        | otherwise = m : enumFromTo (m + 1) n

### 試してみる

編集用と対話環境用にコマンドプロンプトを2個立ち上げる。

lectures/lecture08ディレクトリを作成し、そこに移動。
myList.hsを作成して以下を書き込む。

    myEnumFromTo :: Int -> Int -> [Int]
    myEnumFromTo m n
        | m > n = []
        | otherwise = m : enumFromTo (m + 1) n

試してみる。

    % ghci myList.hs
    *Main> myEnumFromTo 3 8
    [3,4,5,6,7,8]

### 関数myEnumFromToの説明

関数myEnumFromToの定義は以下のように読むことができる。

1. 開始の値が終了の値よりも大きければ空リスト
2. mからnまでの値のリストは
    * (m + 1)からnまでの値のリストにmを追加したもの

### まとめ

[m .. n]という構文は構文糖であり、脱糖すると以下のようになる。

    enumFromTo m n

enumFromTo m nは以下のように定義される。

1. m > n ならば空リスト
2. そうでなければm + 1からnのリストにmを追加したもの

リストを作成する関数の多くが同様の枠組みで作られる。
その枠組みとは、その関数自体の返り値に値を追加するというもの。

コラッツの予想
--------------

### コラッツの予想とは

正の整数nについて、nが偶数ならば2で割り、nが奇数ならば3をかけて1を足す、
という操作をくりかえす行っていくと、いつかは以下のループになるという予想。

    4 -> 2 -> 1 -> 4 -> 2 -> 1 -> 4 -> ...

まだ証明されていない。
数学における未解決問題のひとつである。
現在では3 * 2 ^ 53までのnで成り立つことが確認されている。

    27021597764222976
    (二京七千二十一兆五千九百七十七億六千四百二十二万二千九百七十六)

### コラッツ数列

数nから始めて、コラッツ予想のルールで次を求めていき1が来たら終了とする数列である。
コラッツ数列を求める関数を書いていくことにする。

この関数は2つの部分に分けることができる。

1. 既述のルールを適用し続ける無限リストを作る
2. 上記のリストのうち最初に1が出るところまでとる

つまり、「くりかえす」の部分と終了条件とを分けた、ということ。

### 最初の1までをとる

#### より一般的に

まずは2.の1までをとる処理について考えよう。
これはより一般的には
「引数で指定された条件を満たすまでをとる関数」とすることができる。
この関数をtakeToという名前にする。

#### 型

この関数の入出力の型は

    入力1: a -> Bool
    入力2: [a]
    出力 : [a]

よって以下のようになる。

    takeTo :: (a -> Bool) -> [a] -> [a]

#### 再帰的な定義

##### 基底部1

空リストの場合は結果も空リストとなるので、

    takeTo _ [] = []

##### 基底部2

リストの先頭の要素が条件を満たす場合、
その要素の後ろは捨てるので、

    takeTo p (x : xs)
        | p x = [x]

##### 再帰部

pを満たさない場合はxsからpを満たす要素までを取り、
そのリストにxを追加すれば良い。

        | otherwise = x : takeTo p xs

#### 試してみる

以下を、collatz.hsに書き込む。

    takeTo :: (a -> Bool) -> [a] -> [a]
    takeTo _ [] = []
    takeTo p (x : xs)
        | p x = [x]
        | otherwise = x : takeTo p xs

使ってみよう。

    *Main> :load collatz.hs
    *Main> takeTo even [3, 11, 17, 2, 4, 3, 8]
    [3,11,17,2]

#### foldrを使った定義

以下のような関数を考える。

    fun x lst = if p x then [x] else x : lst

すると、takeToの定義は以下のように書き換えられる。

    takeTo p (x : xs) = fun x (takeTo p xs)

これを中置記法にすると

    takeTo p (x : xs) = x `fun` takeTo p xs

以下のように書くことができる。

    (takeTo p) [] = []
    (takeTo p) (x : xs) = x `fun` (takeTo p) xs

(takeTo p)は以下の変換を行う関数と見ることができる。

* []は[]にする
* (:)をfunに置き換える

このパターンはfoldrの枠組みにあてはめられるので

    takeTo p = foldr fun []

funの中身を展開すると

    takeTo p = foldr (\x lst -> if p x then [x] else x : lst) []

#### ポイントフリースタイル

#### 重複をなくす

#### ポイントフリースタイル狂
