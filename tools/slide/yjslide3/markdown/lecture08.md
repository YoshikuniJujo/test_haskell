第8回 リストを作る再帰関数
==========================

はじめに
--------

前回はリストを引数に取る再帰関数について学んだ。
今回はリストを返す再帰関数について学ぶ。

「リスト」の回でやった3段階は

1. enumerate
2. map/filter
3. accumulate

であるが、そのうちの1. enumerateにあたる部分となる。

[m .. n]
--------

### 構文糖

「リスト」の回で見た[m .. n]という構文を見る。
これは構文糖であり脱糖すると以下の関数になる。

    enumFromTo m n

### 型

この関数の型を正確に理解するためには後でやる型クラスの知識が必要になる。
今回はとりあえず以下のように理解しておこう。

    enumFromTo :: Int -> Int -> [Int]

### 定義

enumFromTo n mはmから1刻みでnまでのリストを返す関数であり、
以下のように定義できる。

    enumFromTo m n
        | m > n = []
        | otherwise = m : enumFromTo (m + 1) n

### 試してみる

編集用と対話環境用にコマンドプロンプトを2個立ち上げる。

lectures/lecture08ディレクトリを作成し、そこに移動。
myList.hsを作成して以下を書き込む。

    myEnumFromTo :: Int -> Int -> [Int]
    myEnumFromTo m n
        | m > n = []
        | otherwise = m : enumFromTo (m + 1) n

試してみる。

    % ghci myList.hs
    *Main> myEnumFromTo 3 8
    [3,4,5,6,7,8]

### 関数myEnumFromToの説明

関数myEnumFromToの定義は以下のように読むことができる。

1. 開始の値が終了の値よりも大きければ空リスト
2. mからnまでの値のリストは
    * (m + 1)からnまでの値のリストにmを追加したもの

### まとめ

[m .. n]という構文は構文糖であり、脱糖すると以下のようになる。

    enumFromTo m n

enumFromTo m nは以下のように定義される。

1. m > n ならば空リスト
2. そうでなければm + 1からnのリストにmを追加したもの

リストを作成する関数の多くが同様の枠組みで作られる。
その枠組みとは、その関数自体の返り値に値を追加するというもの。

コラッツの予想
--------------

### コラッツの予想とは

正の整数nについて、nが偶数ならば2で割り、nが奇数ならば3をかけて1を足す、
という操作をくりかえす行っていくと、いつかは以下のループになるという予想。

    4 -> 2 -> 1 -> 4 -> 2 -> 1 -> 4 -> ...

まだ証明されていない。
数学における未解決問題のひとつである。
現在では3 * 2 ^ 53までのnで成り立つことが確認されている。

    27021597764222976
    (二京七千二十一兆五千九百七十七億六千四百二十二万二千九百七十六)

### コラッツ数列

数nから始めて、コラッツ予想のルールで次を求めていき1が来たら終了とする数列である。
コラッツ数列を求める関数を書いていくことにする。

この関数は2つの部分に分けることができる。

1. 既述のルールを適用し続ける無限リストを作る
2. 上記のリストのうち最初に1が出るところまでとる

つまり、「くりかえす」の部分と終了条件とを分けた、ということ。

### 最初の1までをとる

#### より一般的に

まずは2.の1までをとる処理について考えよう。
これはより一般的には
「引数で指定された条件を満たすまでをとる関数」とすることができる。
この関数をtakeToという名前にする。

#### 型

この関数の入出力の型は

    入力1: a -> Bool
    入力2: [a]
    出力 : [a]

よって以下のようになる。

    takeTo :: (a -> Bool) -> [a] -> [a]

#### 再帰的な定義

##### 基底部1

空リストの場合は結果も空リストとなるので、

    takeTo _ [] = []

##### 基底部2

リストの先頭の要素が条件を満たす場合、
その要素の後ろは捨てるので、

    takeTo p (x : xs)
        | p x = [x]

##### 再帰部

pを満たさない場合はxsからpを満たす要素までを取り、
そのリストにxを追加すれば良い。

        | otherwise = x : takeTo p xs

#### 試してみる

以下を、collatz.hsに書き込む。

    takeTo :: (a -> Bool) -> [a] -> [a]
    takeTo _ [] = []
    takeTo p (x : xs)
        | p x = [x]
        | otherwise = x : takeTo p xs

使ってみよう。

    *Main> :load collatz.hs
    *Main> takeTo even [3, 11, 17, 2, 4, 3, 8]
    [3,11,17,2]

#### foldrを使った定義

以下のような関数を考える。

    fun x lst = if p x then [x] else x : lst

すると、takeToの定義は以下のように書き換えられる。

    takeTo p (x : xs) = fun x (takeTo p xs)

これを中置記法にすると

    takeTo p (x : xs) = x `fun` takeTo p xs

以下のように書くことができる。

    (takeTo p) [] = []
    (takeTo p) (x : xs) = x `fun` (takeTo p) xs

(takeTo p)は以下の変換を行う関数と見ることができる。

* []は[]にする
* (:)をfunに置き換える

このパターンはfoldrの枠組みにあてはめられるので

    takeTo p = foldr fun []

funの中身を展開すると

    takeTo p = foldr (\x lst -> if p x then [x] else x : lst) []

#### ポイントフリースタイル

funを以下のように書き換えることができる。

       \x lst -> if p x then [x] else x : lst
    -> \x -> if p x then \_ -> [x] else (x :)

\_ -> cのような形は引数に関わらず一定の値を返す関数である。
そのような関数を作る関数constがある。

    const c = \_ -> c

これを作ってさらに書き換えると

    \x -> if p x then const [x] else (x :)

もともとの定義と書き換えたあとの定義とを見くらべてみよう。

    \x lst -> if p x then [x] else x : lst
    \x -> if p x then const [x] else (x :)

Haskellに慣れてくると後者のほうが「美しく」感じる。
lstという変数はfooでもbarでも何でも良い。
lstという名前を選んだのは恣意的な選択である。

よって、そのような「恣意性」が減少する後者のほうが美しい。

仮引数を使わないスタイルをポイントフリースタイルと呼ぶ。
ポイントフリースタイルを適度に使うとコードが引きしまる。

また、その関数をより「直接的に」定義することができる。
例として

    add2 x = x + 2
    add2 = (+ 2)

前者は「引数xに2を足す関数」だが、後者は「2を足す関数」となり、
より直接的なのは後者である。

#### 重複をなくす

ポイントフリースタイルにはしたが、実はこのコードには隠れた重複がある。

    \x -> if p x then const [x] else (x :)

[x]が(x : [])という意味であることを思い出そう。
つまりif文のthen部とelse部とで(x :)が重複している。
以下のようにするとその重複を消すことができる。

    \x -> (x :) . if p x then const [] else id

ここで、idは入力をそのまま出力とする関数である。

    id x = x

#### 試してみる

collatz.hsに書き込む。

    takeTo' :: (a -> Bool) -> [a] -> [a]
    takeTo' p = flip foldr [] $
        \x -> (x :) . if p x then const [] else id

flipは引数の順番を入れ換える関数である。

    flip f = \x y -> f y x

flipと($)を利用することで()の数を減らしてみた。

対話環境で試してみよう。

    *Main> :reload
    *Main> takeTo' even [3, 11, 17, 2, 4, 3, 8]
    [3,11,17,2]

#### ポイントフリースタイル狂

ポイントフリースタイルには多少中毒性がある。
引数を書かない表現をつきつめてみたくなることがある。

takeToを完全にポイントフリースタイルで書くと以下のようになる。

    takeTo = flip foldr [] . ((.) <$> (:) <*>) .
        ((([id, const []] !!) . fromEnum) .)

ポイントフリースタイルは「適度に」使うとコードがわかりやすくなるが...。

#### まとめ

条件を満たす最初の要素までをとる関数takeToを作った。
まずは再帰的な定義で書いた。

次に、(:)を置き換える関数を考えることでfoldrを使った定義に書き換えた。

また、ポイントフリースタイルについて触れた。
ポイントフリースタイルはコードから贅肉をそぎおとすが、
やりすぎるとパズルになってしまうことを見た。

このtakeToを使えばリストから最初の1までをとる処理は以下のように書ける。

    takeTo (== 1) [...]
