第8回 リストを作る再帰関数
==========================

はじめに
--------

前回はリストを引数に取る再帰関数について学んだ。
今回はリストを返す再帰関数について学ぶ。

「リスト」の回でやった3段階は

1. enumerate
2. map/filter
3. accumulate

であるが、そのうちの1. enumerateにあたる部分となる。

[m .. n]
--------

### 構文糖

「リスト」の回で見た[m .. n]という構文を見る。
これは構文糖であり脱糖すると以下の関数になる。

    enumFromTo m n

### 型

この関数の型を正確に理解するためには後でやる型クラスの知識が必要になる。
今回はとりあえず以下のように理解しておこう。

    enumFromTo :: Int -> Int -> [Int]

### 定義

enumFromTo n mはmから1刻みでnまでのリストを返す関数であり、
以下のように定義できる。

    enumFromTo m n
        | m > n = []
        | otherwise = m : enumFromTo (m + 1) n

### 試してみる

編集用と対話環境用にコマンドプロンプトを2個立ち上げる。

lectures/lecture08ディレクトリを作成し、そこに移動。
myList.hsを作成して以下を書き込む。

    myEnumFromTo :: Int -> Int -> [Int]
    myEnumFromTo m n
        | m > n = []
        | otherwise = m : enumFromTo (m + 1) n

試してみる。

    % ghci myList.hs
    *Main> myEnumFromTo 3 8
    [3,4,5,6,7,8]

### 関数myEnumFromToの説明

関数myEnumFromToの定義は以下のように読むことができる。

1. 開始の値が終了の値よりも大きければ空リスト
2. mからnまでの値のリストは
    * (m + 1)からnまでの値のリストにmを追加したもの

### まとめ

[m .. n]という構文は構文糖であり、脱糖すると以下のようになる。

    enumFromTo m n

enumFromTo m nは以下のように定義される。

1. m > n ならば空リスト
2. そうでなければm + 1からnのリストにmを追加したもの

リストを作成する関数の多くが同様の枠組みで作られる。
その枠組みとは、その関数自体の返り値に値を追加するというもの。

コラッツの予想
--------------

### コラッツの予想とは

正の整数nについて、nが偶数ならば2で割り、nが奇数ならば3をかけて1を足す、
という操作をくりかえす行っていくと、いつかは以下のループになるという予想。

    4 -> 2 -> 1 -> 4 -> 2 -> 1 -> 4 -> ...

まだ証明されていない。
数学における未解決問題のひとつである。
現在では3 * 2 ^ 53までのnで成り立つことが確認されている。

    27021597764222976
    (二京七千二十一兆五千九百七十七億六千四百二十二万二千九百七十六)

### コラッツ数列

数nから始めて、コラッツ予想のルールで次を求めていき1が来たら終了とする数列である。
コラッツ数列を求める関数を書いていくことにする。

この関数は2つの部分に分けることができる。

1. 既述のルールを適用し続ける無限リストを作る
2. 上記のリストのうち最初に1が出るところまでとる

つまり、「くりかえす」の部分と終了条件とを分けた、ということ。

### 最初の1までをとる

#### より一般的に

まずは2.の1までをとる処理について考えよう。
これはより一般的には
「引数で指定された条件を満たすまでをとる関数」とすることができる。
この関数をtakeToという名前にする。

#### 型

この関数の入出力の型は

    入力1: a -> Bool
    入力2: [a]
    出力 : [a]

よって以下のようになる。

    takeTo :: (a -> Bool) -> [a] -> [a]

#### 再帰的な定義

##### 基底部1

空リストの場合は結果も空リストとなるので、

    takeTo _ [] = []

##### 基底部2

リストの先頭の要素が条件を満たす場合、
その要素の後ろは捨てるので、

    takeTo p (x : xs)
        | p x = [x]

##### 再帰部

pを満たさない場合はxsからpを満たす要素までを取り、
そのリストにxを追加すれば良い。

        | otherwise = x : takeTo p xs

#### 試してみる

以下を、collatz.hsに書き込む。

    takeTo :: (a -> Bool) -> [a] -> [a]
    takeTo _ [] = []
    takeTo p (x : xs)
        | p x = [x]
        | otherwise = x : takeTo p xs

使ってみよう。

    *Main> :load collatz.hs
    *Main> takeTo even [3, 11, 17, 2, 4, 3, 8]
    [3,11,17,2]

#### foldrを使った定義

以下のような関数を考える。

    fun x lst = if p x then [x] else x : lst

すると、takeToの定義は以下のように書き換えられる。

    takeTo p (x : xs) = fun x (takeTo p xs)

これを中置記法にすると

    takeTo p (x : xs) = x `fun` takeTo p xs

以下のように書くことができる。

    (takeTo p) [] = []
    (takeTo p) (x : xs) = x `fun` (takeTo p) xs

(takeTo p)は以下の変換を行う関数と見ることができる。

* []は[]にする
* (:)をfunに置き換える

このパターンはfoldrの枠組みにあてはめられるので

    takeTo p = foldr fun []

funの中身を展開すると

    takeTo p = foldr (\x lst -> if p x then [x] else x : lst) []

#### ポイントフリースタイル

funを以下のように書き換えることができる。

       \x lst -> if p x then [x] else x : lst
    -> \x -> if p x then \_ -> [x] else (x :)

\_ -> cのような形は引数に関わらず一定の値を返す関数である。
そのような関数を作る関数constがある。

    const c = \_ -> c

これを作ってさらに書き換えると

    \x -> if p x then const [x] else (x :)

もともとの定義と書き換えたあとの定義とを見くらべてみよう。

    \x lst -> if p x then [x] else x : lst
    \x -> if p x then const [x] else (x :)

Haskellに慣れてくると後者のほうが「美しく」感じる。
lstという変数はfooでもbarでも何でも良い。
lstという名前を選んだのは恣意的な選択である。

よって、そのような「恣意性」が減少する後者のほうが美しい。

仮引数を使わないスタイルをポイントフリースタイルと呼ぶ。
ポイントフリースタイルを適度に使うとコードが引きしまる。

また、その関数をより「直接的に」定義することができる。
例として

    add2 x = x + 2
    add2 = (+ 2)

前者は「引数xに2を足す関数」だが、後者は「2を足す関数」となり、
より直接的なのは後者である。

#### 重複をなくす

ポイントフリースタイルにはしたが、実はこのコードには隠れた重複がある。

    \x -> if p x then const [x] else (x :)

[x]が(x : [])という意味であることを思い出そう。
つまりif文のthen部とelse部とで(x :)が重複している。
以下のようにするとその重複を消すことができる。

    \x -> (x :) . if p x then const [] else id

ここで、idは入力をそのまま出力とする関数である。

    id x = x

#### 試してみる

collatz.hsに書き込む。

    takeTo' :: (a -> Bool) -> [a] -> [a]
    takeTo' p = flip foldr [] $
        \x -> (x :) . if p x then const [] else id

flipは引数の順番を入れ換える関数である。

    flip f = \x y -> f y x

flipと($)を利用することで()の数を減らしてみた。

対話環境で試してみよう。

    *Main> :reload
    *Main> takeTo' even [3, 11, 17, 2, 4, 3, 8]
    [3,11,17,2]

#### ポイントフリースタイル狂

ポイントフリースタイルには多少中毒性がある。
引数を書かない表現をつきつめてみたくなることがある。

takeToを完全にポイントフリースタイルで書くと以下のようになる。

    takeTo = flip foldr [] . ((.) <$> (:) <*>) .
        ((([id, const []] !!) . fromEnum) .)

ポイントフリースタイルは「適度に」使うとコードがわかりやすくなるが...。

#### まとめ

条件を満たす最初の要素までをとる関数takeToを作った。
まずは再帰的な定義で書いた。

次に、(:)を置き換える関数を考えることでfoldrを使った定義に書き換えた。

また、ポイントフリースタイルについて触れた。
ポイントフリースタイルはコードから贅肉をそぎおとすが、
やりすぎるとパズルになってしまうことを見た。

このtakeToを使えばリストから最初の1までをとる処理は以下のように書ける。

    takeTo (== 1) [...]

### 無限数列を作る

#### 前の値から次の値を作る

コラッツ数列の作りかたを再掲する。

* nが偶数ならば2で割る
* nが奇数ならば3をかけて1を足す

よって前の値から次の値を求める関数は以下のようになる。

    collatzNext :: Int -> Int
    collatzNext n
        | even n = n `div` 2
        | otherwise = n * 3 + 1

#### 無限数列を作る

以下のようにして無限数列を作る。

    collatzInf :: Int -> [Int]
    collatzInf n = n : collatzInf (collatzNext n)

nから始まる数列はnの次から始まる数列にnを追加したもの、ということ。

結果は次のような数列になる。

    [n, collatzNext n, collatzNext (collatzNext n) ...]

これを一般化すると

    [x, f x, f (f x), f (f (f x)), f (f (f (f x))) ...]

#### iterateを使う

上のような形の列はしばしば使われるので、専用の関数が用意されている。

    iterate f x == [x, f x, f (f x), f (f (f x)) ...]

iterateを使うと

    collatzInf = iterate collatzNext

collatzNextを展開すると

    collatzInf = iterate $ \n -> if even n
        then n `div` 2
        else n * 3 + 1

#### 試してみる

collatz.hsに以下を書き込む。

    collatzInf :: Int -> [Int]
    collatzInf = iterate $ \n -> if even n
        then n `div` 2
        else n * 3 + 1

試してみる。

    *Main> :reload
    *Main> take 10 $ collatzInf 24
    [24,12,6,3,10,5,16,8,4,2]

#### iterateについて

iterateの定義を見てみよう。
型は以下のようになる。

    iterate :: (a -> a) -> a -> [a]

定義は以下のようになる。

    iterate f x = x : iterate f (f x)

xに次々とfを適用していってできるリストは、
f xに次々とfを適用していってできるリストの先頭に
xを追加したもの、ということ。

#### まとめ

次の値が前の値に関数fを適用したものであるようなリストは、
以下のようにして作ることができる。

    mkSomeList x = x : mkSomeList (f x)

この枠組みを関数として取り出したものがiterate関数である。

    iterate f x == [x, f x, f (f x), f (f (f x)) ...]

### 組み合わせる

無限数列から1までを取ることによってコラッツ数列を作ろう。

    collatz :: Int -> [Int]
    collatz = takeTo (== 1) . collatzInf

これをcollatz.hsに書き込み、試してみる。

    *Main> :reload
    *Main> collatz 11
    [11,34,17,52,26,13,40,20,10,5,16,8,4,2,1]

### まとめ

コラッツ数列を返す関数を作った。
無限数列を作ってから必要な部分だけを取り出すというやりかたをした。
つまり、「次々に値を生成する」部分と「終了条件」とを分けたということ。

後者を実現するために、条件を満たすまでを取り出す関数を作った。
その関数を再帰を直接使う方法とfoldrを使う方法とで書いてみた。
また、ポイントフリースタイルは適度に使用するのが良いということを学んだ。

「値に次々と関数を適用する」リストという枠組みについて学んだ。
この枠組みは関数iterateによって抽象化されている。
