第8回 リストを作る再帰関数
==========================

はじめに
--------

前回はリストを引数に取る再帰関数について学んだ。
今回はリストを返す再帰関数について学ぶ。

「リスト」の回でやった3段階は

1. enumerate
2. map/filter
3. accumulate

であるが、そのうちの1. enumerateにあたる部分となる。

[m .. n]
--------

### 構文糖

「リスト」の回で見た[m .. n]という構文を見る。
これは構文糖であり脱糖すると以下の関数になる。

    enumFromTo m n

### 型

この関数の型を正確に理解するためには後でやる型クラスの知識が必要になる。
今回はとりあえず以下のように理解しておこう。

    enumFromTo :: Int -> Int -> [Int]

### 定義

enumFromTo n mはmから1刻みでnまでのリストを返す関数であり、
以下のように定義できる。

    enumFromTo m n
        | m > n = []
        | otherwise = m : enumFromTo (m + 1) n

### 試してみる

編集用と対話環境用にコマンドプロンプトを2個立ち上げる。

lectures/lecture08ディレクトリを作成し、そこに移動。
myList.hsを作成して以下を書き込む。

    myEnumFromTo :: Int -> Int -> [Int]
    myEnumFromTo m n
        | m > n = []
        | otherwise = m : enumFromTo (m + 1) n

試してみる。

    % ghci myList.hs
    *Main> myEnumFromTo 3 8
    [3,4,5,6,7,8]

### 関数myEnumFromToの説明

関数myEnumFromToの定義は以下のように読むことができる。

1. 開始の値が終了の値よりも大きければ空リスト
2. mからnまでの値のリストは
    * (m + 1)からnまでの値のリストにmを追加したもの

### まとめ

[m .. n]という構文は構文糖であり、脱糖すると以下のようになる。

    enumFromTo m n

enumFromTo m nは以下のように定義される。

1. m > n ならば空リスト
2. そうでなければm + 1からnのリストにmを追加したもの

リストを作成する関数の多くが同様の枠組みで作られる。
その枠組みとは、その関数自体の返り値に値を追加するというもの。

コラッツの予想
--------------

### コラッツの予想とは

正の整数nについて、nが偶数ならば2で割り、nが奇数ならば3をかけて1を足す、
という操作をくりかえす行っていくと、いつかは以下のループになるという予想。

    4 -> 2 -> 1 -> 4 -> 2 -> 1 -> 4 -> ...

まだ証明されていない。
数学における未解決問題のひとつである。
現在では3 * 2 ^ 53までのnで成り立つことが確認されている。

    27021597764222976
    (二京七千二十一兆五千九百七十七億六千四百二十二万二千九百七十六)

### コラッツ数列

数nから始めて、コラッツ予想のルールで次を求めていき1が来たら終了とする数列である。
コラッツ数列を求める関数を書いていくことにする。

この関数は2つの部分に分けることができる。

1. 既述のルールを適用し続ける無限リストを作る
2. 上記のリストのうち最初に1が出るところまでとる

つまり、「くりかえす」の部分と終了条件とを分けた、ということ。

### 最初の1までをとる

#### より一般的に

まずは2.の1までをとる処理について考えよう。
これはより一般的には
「引数で指定された条件を満たすまでをとる関数」とすることができる。
この関数をtakeToという名前にする。

#### 型

この関数の入出力の型は

    入力1: a -> Bool
    入力2: [a]
    出力 : [a]

よって以下のようになる。

    takeTo :: (a -> Bool) -> [a] -> [a]

#### 再帰的な定義

##### 基底部1

空リストの場合は結果も空リストとなるので、

    takeTo _ [] = []

##### 基底部2

リストの先頭の要素が条件を満たす場合、
その要素の後ろは捨てるので、

    takeTo p (x : xs)
        | p x = [x]

##### 再帰部

pを満たさない場合はxsからpを満たす要素までを取り、
そのリストにxを追加すれば良い。

        | otherwise = x : takeTo p xs

#### 試してみる

以下を、collatz.hsに書き込む。

    takeTo :: (a -> Bool) -> [a] -> [a]
    takeTo _ [] = []
    takeTo p (x : xs)
        | p x = [x]
        | otherwise = x : takeTo p xs

使ってみよう。

    *Main> :load collatz.hs
    *Main> takeTo even [3, 11, 17, 2, 4, 3, 8]
    [3,11,17,2]

#### foldrを使った定義

以下のような関数を考える。

    fun x lst = if p x then [x] else x : lst

すると、takeToの定義は以下のように書き換えられる。

    takeTo p (x : xs) = fun x (takeTo p xs)

これを中置記法にすると

    takeTo p (x : xs) = x `fun` takeTo p xs

以下のように書くことができる。

    (takeTo p) [] = []
    (takeTo p) (x : xs) = x `fun` (takeTo p) xs

(takeTo p)は以下の変換を行う関数と見ることができる。

* []は[]にする
* (:)をfunに置き換える

このパターンはfoldrの枠組みにあてはめられるので

    takeTo p = foldr fun []

funの中身を展開すると

    takeTo p = foldr (\x lst -> if p x then [x] else x : lst) []

#### ポイントフリースタイル

funを以下のように書き換えることができる。

       \x lst -> if p x then [x] else x : lst
    -> \x -> if p x then \_ -> [x] else (x :)

\_ -> cのような形は引数に関わらず一定の値を返す関数である。
そのような関数を作る関数constがある。

    const c = \_ -> c

これを作ってさらに書き換えると

    \x -> if p x then const [x] else (x :)

もともとの定義と書き換えたあとの定義とを見くらべてみよう。

    \x lst -> if p x then [x] else x : lst
    \x -> if p x then const [x] else (x :)

Haskellに慣れてくると後者のほうが「美しく」感じる。
lstという変数はfooでもbarでも何でも良い。
lstという名前を選んだのは恣意的な選択である。

よって、そのような「恣意性」が減少する後者のほうが美しい。

仮引数を使わないスタイルをポイントフリースタイルと呼ぶ。
ポイントフリースタイルを適度に使うとコードが引きしまる。

また、その関数をより「直接的に」定義することができる。
例として

    add2 x = x + 2
    add2 = (+ 2)

前者は「引数xに2を足す関数」だが、後者は「2を足す関数」となり、
より直接的なのは後者である。

#### 重複をなくす

ポイントフリースタイルにはしたが、実はこのコードには隠れた重複がある。

    \x -> if p x then const [x] else (x :)

[x]が(x : [])という意味であることを思い出そう。
つまりif文のthen部とelse部とで(x :)が重複している。
以下のようにするとその重複を消すことができる。

    \x -> (x :) . if p x then const [] else id

ここで、idは入力をそのまま出力とする関数である。

    id x = x

#### 試してみる

collatz.hsに書き込む。

    takeTo' :: (a -> Bool) -> [a] -> [a]
    takeTo' p = flip foldr [] $
        \x -> (x :) . if p x then const [] else id

flipは引数の順番を入れ換える関数である。

    flip f = \x y -> f y x

flipと($)を利用することで()の数を減らしてみた。

対話環境で試してみよう。

    *Main> :reload
    *Main> takeTo' even [3, 11, 17, 2, 4, 3, 8]
    [3,11,17,2]

#### ポイントフリースタイル狂

ポイントフリースタイルには多少中毒性がある。
引数を書かない表現をつきつめてみたくなることがある。

takeToを完全にポイントフリースタイルで書くと以下のようになる。

    takeTo = flip foldr [] . ((.) <$> (:) <*>) .
        ((([id, const []] !!) . fromEnum) .)

ポイントフリースタイルは「適度に」使うとコードがわかりやすくなるが...。

#### まとめ

条件を満たす最初の要素までをとる関数takeToを作った。
まずは再帰的な定義で書いた。

次に、(:)を置き換える関数を考えることでfoldrを使った定義に書き換えた。

また、ポイントフリースタイルについて触れた。
ポイントフリースタイルはコードから贅肉をそぎおとすが、
やりすぎるとパズルになってしまうことを見た。

このtakeToを使えばリストから最初の1までをとる処理は以下のように書ける。

    takeTo (== 1) [...]

### 無限数列を作る

#### 前の値から次の値を作る

コラッツ数列の作りかたを再掲する。

* nが偶数ならば2で割る
* nが奇数ならば3をかけて1を足す

よって前の値から次の値を求める関数は以下のようになる。

    collatzNext :: Int -> Int
    collatzNext n
        | even n = n `div` 2
        | otherwise = n * 3 + 1

#### 無限数列を作る

以下のようにして無限数列を作る。

    collatzInf :: Int -> [Int]
    collatzInf n = n : collatzInf (collatzNext n)

nから始まる数列はnの次から始まる数列にnを追加したもの、ということ。

結果は次のような数列になる。

    [n, collatzNext n, collatzNext (collatzNext n) ...]

これを一般化すると

    [x, f x, f (f x), f (f (f x)), f (f (f (f x))) ...]

#### iterateを使う

上のような形の列はしばしば使われるので、専用の関数が用意されている。

    iterate f x == [x, f x, f (f x), f (f (f x)) ...]

iterateを使うと

    collatzInf = iterate collatzNext

collatzNextを展開すると

    collatzInf = iterate $ \n -> if even n
        then n `div` 2
        else n * 3 + 1

#### 試してみる

collatz.hsに以下を書き込む。

    collatzInf :: Int -> [Int]
    collatzInf = iterate $ \n -> if even n
        then n `div` 2
        else n * 3 + 1

試してみる。

    *Main> :reload
    *Main> take 10 $ collatzInf 24
    [24,12,6,3,10,5,16,8,4,2]

#### iterateについて

iterateの定義を見てみよう。
型は以下のようになる。

    iterate :: (a -> a) -> a -> [a]

定義は以下のようになる。

    iterate f x = x : iterate f (f x)

xに次々とfを適用していってできるリストは、
f xに次々とfを適用していってできるリストの先頭に
xを追加したもの、ということ。

#### まとめ

次の値が前の値に関数fを適用したものであるようなリストは、
以下のようにして作ることができる。

    mkSomeList x = x : mkSomeList (f x)

この枠組みを関数として取り出したものがiterate関数である。

    iterate f x == [x, f x, f (f x), f (f (f x)) ...]

### 組み合わせる

無限数列から1までを取ることによってコラッツ数列を作ろう。

    collatz :: Int -> [Int]
    collatz = takeTo (== 1) . collatzInf

これをcollatz.hsに書き込み、試してみる。

    *Main> :reload
    *Main> collatz 11
    [11,34,17,52,26,13,40,20,10,5,16,8,4,2,1]

### まとめ

コラッツ数列を返す関数を作った。
無限数列を作ってから必要な部分だけを取り出すというやりかたをした。
つまり、「次々に値を生成する」部分と「終了条件」とを分けたということ。

後者を実現するために、条件を満たすまでを取り出す関数を作った。
その関数を再帰を直接使う方法とfoldrを使う方法とで書いてみた。
また、ポイントフリースタイルは適度に使用するのが良いということを学んだ。

「値に次々と関数を適用する」リストという枠組みについて学んだ。
この枠組みは関数iterateによって抽象化されている。

素因数分解
----------

### 素因数分解とは

数を素数の積で表現することを素因数分解と呼ぶ。

    420 = 2 * 2 * 3 * 5 * 7

素因数分解は桁が大きくなると計算量が著しく増加する。
大きな値を素因数分解する効率的なアルゴリズムは現在のところ存在しない。
むしろ、それを利用したRSA暗号がある。

### Int型

素因数分解のなかで、大きな素数が出てきてしまうと、
演算速度的に無理が出てくるので、あまり大きな数は扱わない。
しかし、ある程度の大きさの合成数は扱うことにする。

今までは整数としてInt型の値を使ってきたが、Intは処理系依存のサイズの整数型である。
仕様ではすくなくとも以下の範囲が表現可能であるとされている。

    (- 2 ^ 29)から(2 ^ 29 - 1)

自分の処理系のInt型の値の範囲は以下のように確かめられる。

    *Main> (minBound, maxBound) :: (Int, Int)
    (-2147483648,2147483647)

実はInt型は大きな値に対しては安全ではない。

    *Main> maxBound :: Int
    2147483647
    *Main> maxBound + 1 :: Int
    -2147483648

2147483647 + 1 = -2147483648となってしまう。

Int型はmaxBoundとminBoundとがつながった円環構造と考える必要がある。

### Integer型

Haskellにはより安全なInteger型があり、
メモリが許すかぎりの大きさの整数を扱うことができる。

実際に試してみる。

    *Main> 2 ^ 128
    340282366920938463463374607431768211456
    *Main> product [1 .. 100]
    933262154439441526816992388562667004907159682643816214685929638
    952175999932299156089414639761565182862536979208272237582511852
    10916864000000000000000000000000

今回の例題にはInteger型を利用することにする。

### 戦略

問題を以下のように分割する。

1. 整数を2以上の最小の約数と残りの数に分ける
2. 1を残りの数についてくりかえす

つまり、最小の約数をつぎつぎと取り出していくということ。

### 整数を分ける

#### アルゴリズム

ここでは効率のことは考えずに単純することを優先する。
2以上の最小の約数を探す部分は、以下のようなアルゴリズムにする。

引数nについて

1. 2から数nまでのリストを作る
2. それらでnを割り0になるものだけを集める
3. その先頭の要素を取り出す

#### 関数の定義

整数nを最小の約数と残りに分ける関数は以下のようになる。

    popFactor :: Integer -> Maybe (Integer, Integer)
    popFactor 1 = Nothing
    popFactor n = Just (f, n `div` f)
        where
        f = head $ filter ((== 0) . (n `mod`)) [2 .. n]

#### 関数の説明

##### 返り値をMaybe型にした点

返り値をMaybe ...とし、1のときにNothingを返すようにした。
以下のようにすることもできた。

    popFactor 1 = (1, 1)

しかし、このようにすると「残り」が変化しなくなり、
最終的に目的とする関数が無限ループになってしまう。

よってpopFactor 1の返り値をNothingとして
「1になったら終了」という条件を明確にした。

##### filter部

filterの部分がすこし難しいかもしれない。

    filter ((== 0) . (n `mod`))

これをポイントフリーでないスタイルで書くと

    filter (\x -> n `mod` x == 0)

つまり、nを割った余りが0になるxを取り出すということになる。

#### 試してみる

factorization.hsに以下を書き込む。

    popFactor :: Integer -> Maybe (Integer, Integer)
    popFactor n = (f, n `div` f)
        where
        f = head $ filter ((== 0) . (n `mod`)) [2 .. n]

試してみる。

    *Main> :load factorization.hs
    *Main> popFactor 55
    (5, 11)
    *Main> popFactor 61
    (61, 1)

### 素因数分解

#### アルゴリズム

最小の因数と残りの数に分ける関数ができたので、
これを使って素因数分解する関数を作る。
結果がJustかNothingかによって場合分けし、以下のような動作とする。

1. popFactorの結果がNothingだったら空リストとする
2. そうでなければ返り値をJust (f, n')でマッチして
    + n'の素因数分解の結果にfを追加すれば良い

#### 関数の定義

よって以下のようになる。

    factorization :: Integer -> [Integer]
    factorization n = case popFactor n of
        Nothing -> []
        Just (f, n') -> f : factorization n

#### iterateの枠組みとの比較

##### iterateの枠組み

iterateの場合、次々にわたしていく値と結果としてリストに入る値とは同じである。
collatz数列の例で考えると、5の次の値は16だが、この16は結果のリストに入り、
かつ残りの値を求めるのに使われる。

##### 素因数分解では

リストに入るのは最小の約数であり、次の値に必要なのは、残りの数である。
また、リストの終了がNothingで示されている。

この枠組みを表現する関数unfoldrが用意されている。

#### unfoldr

##### unfoldrの枠組み

factorizationの定義から一般的な枠組みを取り出すと

    fun x = case next x of
        Nothing -> []
        Just (r, x') -> r : fun x

このnextの部分を変えればいろいろな関数を作ることができる。
これをunfoldr nextとすることができる。

##### unfoldrの定義

unfoldrの定義は以下のようになる。

    unfoldr :: (b -> Maybe (a, b)) -> b -> [a]
    unfoldr next x = case next x of
        Nothing -> []
        Just (r, x') -> r : unfoldr next x'

##### factorizationの再定義

unfoldrを使うとfactorizationは以下のように書ける。

    factorization = unfoldr popFactor

#### 試してみる

factorization.hsに書き込もう。

    factorization :: Integer -> [Integer]
    factorization = unfoldr popFactor

factorization.hsの先頭に以下を追加する。

    import Data.List (unfoldr)

試してみる。

    *Main> :reload
    *Main> factorization 3511932343773
    [3,7,29209,5725457]
    *Main> factorization 
    [123833,6314339]

### まとめ

unfoldrを利用して、素因数分解する関数を定義した。

unfoldrは「次が存在しないことをNothingで表し、
次が存在する場合には、値に対して(結果, 次の値)のペアを返す関数」を
引数としてとる。
そして、「結果」を要素とするリストを返す。

まとめ
------

リストを構成する再帰関数について見た。
形本的な形としては、その関数の返り値自体に値を追加するという枠組みとなる。

そのような関数の多くは以下のような構造を持つ。

    [x, f x, f (f x), f (f (f x)) ...]

このような構造はiterate f xで表現できる。

これで表現できるリストは多くあるが、
「結果」と「次の値」が違う場合にはiterateは使えない。
このような場合にはunfoldrが使える。
unfoldrは「次の値が存在しない場合はNothingを返し、
そうでなければ、値に対して(結果, 次の値)ペアを返す関数」を
引数としてとる。
