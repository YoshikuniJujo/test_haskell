<div dir="ltr"><div><div>Hi, <br> <br>I am mailing your concerning some bugs that we have found in your Haskell sqlite binding called simplest-sqlite. <br> <br>We have found that some byteStrings and Texts get incorrect values and also that the type Text raises a Text exception. <br> <br>The Text problem seems to only occurs when multiple queries is executed in a row in our QuickCheck property which we have attached in this the mail. <br>However, the bytestring problem can be shown in a single example. <br> <br>The following code is an example when the bytestring error occurs:<br> <br>    let byteStr1 = (B.pack [89,191,210,187,17,34,0,87,101,68]) :: T.ByteString <br>    let byteStr2 = (B.pack [184,60,60,23,29,234,132,51,54,63,16,232,122,0,51]) :: T.ByteString  <br>    let byteStr3 = (B.pack [56,43,93,25,48,56,245,51,84]) :: T.ByteString <br> <br>    ([a,b,c],_) &lt;- withSQLite &quot;test.db&quot; (\db -&gt; do <br>            withPrepared db (&quot;create table abc (A Blob,B Blob,C Blob);&quot;) (\cc -&gt; step cc) <br>            withPrepared db (&quot;insert into abc (A,B,C) values (?1,?2,?3)&quot;) (\stmt -&gt; do  <br>                                                                                    bind stmt &quot;?1&quot; byteStr1 <br>                                                                                    bind stmt &quot;?2&quot; byteStr2  <br>                                                                                    bind stmt &quot;?3&quot; byteStr3  <br>                                                                                    step stmt) <br>            stmt2 &lt;- withPrepared db (&quot;select * from abc&quot;) (\dd -&gt; do  <br>                                                        step dd <br>                                                        byt1 &lt;- column dd (0 :: Int) :: IO T.ByteString <br>                                                        byt2 &lt;- column dd (1 :: Int) :: IO T.ByteString <br>                                                        byt3 &lt;- column dd (2 :: Int) :: IO T.ByteString <br>                                                        return [byt1,byt2,byt3]) :: IO ([T.ByteString], String) <br>            return stmt2) <br>     <br>    print $ a <br>    print $ byteStr1 <br>    print $ b <br>    print $ byteStr2 <br>    print $ c <br>    print $ byteStr3 <br> <br>    print  $ byteStr1 == a <br>    print  $ byteStr2 == b <br>    print  $ byteStr3 == c <br>    return () <br> <br>The outputs is: <br>&quot;Y\191\210\187\DC1\&quot;&quot; <br>&quot;Y\191\210\187\DC1\&quot;\NULWeD&quot; <br>&quot;\184&lt;&lt;\ETB\GS\234\132\&amp;36?\DLE\232z&quot; <br>&quot;\184&lt;&lt;\ETB\GS\234\132\&amp;36?\DLE\232z\NUL3&quot; <br>&quot;8+]\EM08\245\&amp;3T&quot; <br>&quot;8+]\EM08\245\&amp;3T&quot; <br>False <br>False <br>True <br> <br>All should be true <br> <br>We looked at your code and found out that you are using packCString which seems to cut the bytestring at null signs which can be present in middle of bytestrings <br>and therefore make them shorter. We also tried to fix this bug by using BS.packCStringLen in column in the instance of &quot;SQLiteData BS.ByteString&quot; with the following code: <br><br>instance SQLiteData BS.ByteString where<br> <br>column (Stmt sm) i = do <br>            aaa &lt;- c_sqlite3_column_blob sm (fromIntegral i)<br>            bbb &lt;- sqlite3_column_bytes sm (fromIntegral i)<br>            BS.packCStringLen (castPtr aaa, fromIntegral bbb) <br> <br> <br> <br> <br>However, this sometimes adds a null sign at the end of the bytestring which also is incorrect. We looked at your bind too and found out that your using -1 as the fourth parameter to c_sqlite3_bind_blob which is stated in the SQLite documentation to have unspecified behavior. Therefore, we had to change the bind in that instance too with the following code: <br> <br>instance SQLiteData BS.ByteString where <br>bindN = sqlite3BindBlob <br> <br>sqlite3BindBlob :: Stmt -&gt; Int -&gt; BS.ByteString -&gt; IO () <br>sqlite3BindBlob (Stmt sm) i s = BS.useAsCStringLen s $ \(cs,bytes) -&gt; do <br>    outPtr &lt;- mallocBytes bytes <br>    memcpy outPtr cs (fromIntegral bytes) <br>    ret &lt;- sqlite3_bind_blob sm (fromIntegral i) (castPtr outPtr) (fromIntegral bytes) nullFunPtr <br>    when (ret /= sQLITE_OK) $ sqliteThrow &quot;Cannot bind text&quot; ret <br> <br> <br>This seems to fix all problems with bytestring! <br> <br>---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- <br>The problem with Text appears when the property is run with QuickCheck and following exception can appear: <br> <br>*** Failed! Exception: &#39;Cannot decode byte &#39;\x9d&#39;:  <br>Data.Text.Internal.Encoding.decodeUtf8: Invalid UTF-8 stream&#39; (after 4813 tests)   <br> <br>The are also a mismatch error between the inserted string and the extracted string that can appear in the property test. <br> <br> <br>We looked at the problem with Text where it seems that the -1 in fourth parameter of c_sqlite3_bind_text was the problem. When it is -1 then the number of bytes to the first null terminator <br>is the length which might be the problem. To solve this, we changed the bind function of the instance of Text with the following: <br> <br>instance SQLiteData T.Text where <br>bindNList = sqlite3BindString <br> <br>sqlite3BindString :: Stmt -&gt; Int -&gt; String -&gt; IO () <br>sqlite3BindString (Stmt sm) i s = do         <br>        (cptr, len) &lt;- mallocUtf8CStringLen s <br>        ret &lt;- sqlite3_bind_text sm (fromIntegral i) cptr (fromIntegral len) p_free <br>        when (ret /= sQLITE_OK) $ (Database.SmplstSQLite3.free cptr) <br> <br>mallocUtf8CStringLen :: String -&gt; IO CStringLen <br>mallocUtf8CStringLen str = <br>  bracketOnError (Database.SmplstSQLite3.malloc (checkedFromIntegral len)) Database.SmplstSQLite3.free $ \ ptr -&gt; do <br>    pokeArray ptr str&#39; <br>    return (ptr, len) <br>  where (str&#39;, len) = encodeCStringLen str <br> <br>checkedFromIntegral :: (Integral a, Integral b) =&gt; a -&gt; b <br>checkedFromIntegral x <br>  | toInteger x == toInteger y = y <br>  | otherwise = error &quot;safeFromIntegral: cannot convert integer (out of range)&quot; <br>  where y = fromIntegral x <br> <br>encodeCStringLen :: String -&gt; ([CChar], Int) <br>encodeCStringLen str = (str&#39;, length str&#39;) <br>  where str&#39; = fromIntegral &lt;$&gt; UTF8.encode str <br> <br> <br>We also included the file with all proposed fixes in the mail. <br> <br>Best regards<br></div></div>Victor &amp; Jimmy<br><div><div><br></div></div></div>
