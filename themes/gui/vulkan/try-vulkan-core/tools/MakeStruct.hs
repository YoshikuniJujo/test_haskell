{-# LANGUAGE QuasiQuotes #-}
{-# LANGUAGE LambdaCase #-}
{-# OPTIONS_GHC -Wall -fno-warn-tabs #-}

module MakeStruct where

import Data.List
import Data.Char
import Text.Nowdoc
import System.Directory

vulkanCoreH :: FilePath
vulkanCoreH = "/usr/include/vulkan/vulkan_core.h"

directory :: String -> FilePath
directory mn = "../src/" ++ intercalate "/" (init $ sep '.' mn)

sourceFile :: String -> FilePath
sourceFile mn = directory mn ++ "/Core.hsc"

cName :: String -> String -> String
cName mn hsn = "Vk" ++ concat (tail . tail . init $ sep '.' mn) ++ hsn

data Name = Atom String | List String Int deriving Show

showName :: Name -> String
showName = \case
	Atom nm -> "A " ++ nm
	List nm nb -> "L " ++ nm ++ " " ++ show nb

header :: String -> String
header mn = [nowdoc|

-- This file is automatically generated by the tools/makeStruct.hs
--	% stack runghc --cwd tools/ makeStruct

{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE TupleSections #-}
{-# LANGUAGE PatternSynonyms, ViewPatterns #-}
{-# OPTIONS_GHC -Wall -fno-warn-tabs #-}

module |] ++ mn ++ [nowdoc| where

import Foreign.Ptr
import Foreign.Marshal.Array
import Foreign.Storable
import Foreign.C.Struct
import Foreign.C.Struct.TypeSynonyms
import Data.Word
import Data.Int

import Gpu.Vulkan.TypeSynonyms.Core

#include <vulkan/vulkan.h>

|]

make :: String -> [String] -> String -> IO ()
make moduleName hsNames ext = do
	vch <- readFile vulkanCoreH
	let	moduleName' = intercalate "." . init $ sep '.' moduleName
		dss = (\hn -> takeDefinition (cName moduleName' hn) $ lines vch) <$> hsNames
		hsNameDss = zip hsNames dss
	createDirectoryIfMissing True $ directory moduleName

	let	strs = uncurry (makeStruct moduleName') <$> hsNameDss

	writeFile (sourceFile moduleName) $ header moduleName ++ intercalate "\n" strs ++
		if null ext then "" else "\n" ++ ext ++ "\n"

makeStruct :: String -> String -> [(String, Name)] -> String
makeStruct moduleName' hsName defs = "struct \"" ++ hsName ++
	"\" #{size " ++ cName moduleName' hsName ++
	"}\n\t\t#{alignment " ++ cName moduleName' hsName ++ "} [\n" ++
	intercalate ",\n"
		(uncurry (field1 $ cName moduleName' hsName) <$> defs) ++
	" ]\n\t[''Show, ''Storable]\n"

showWithBar :: (a -> String) -> (b -> String) -> (a, b) -> String
showWithBar sa sb (x, y) = sa x ++ "|" ++ sb y

field1 :: String -> String -> Name -> String
field1 csn "VkStructureType" (Atom "sType") = "\t(\"sType\", ''(), [| const $ pure () |],\n" ++
	"\t\t[| \\p _ -> #{poke " ++ csn ++ ", sType} p" ++
	"\n\t\t\t" ++ csnToStructureType csn
field1 csn "void*" (Atom n) = "\t(\"" ++ n ++ "\", ''PtrVoid,\n\t\t[| #{peek " ++
	csn ++ ", " ++ n ++ "} |],\n\t\t[| #{poke " ++
	csn ++ ", " ++ n ++ "} |])"
field1 csn t (Atom n) = "\t(\"" ++ n ++ "\", ''#{type " ++ t ++ "},\n\t\t[| #{peek " ++
	csn ++ ", " ++ n ++ "} |],\n\t\t[| #{poke " ++
	csn ++ ", " ++ n ++ "} |])"
field1 csn t (List nm nb) = "\t(\"" ++ nm ++ "\", ''" ++ listOf t ++ ",\n\t\t[| peekArray " ++
	show nb ++ " . #{ptr " ++ csn ++ ", " ++ nm ++ "}" ++ "|],\n\t\t[| pokeArray . #{ptr " ++
	csn ++ ", " ++ nm ++ "} |])"

csnToStructureType :: String -> String
csnToStructureType csn = "(#{const VK_STRUCTURE_TYPE_" ++
	intercalate "_" (((toUpper <$>) <$>) . drop 2 $ sepUpper csn) ++ "} ::\n" ++
	"\t\t\t\t#{type VkStructureType}) |])"

sepUpper :: String -> [String]
sepUpper "" = [""]
sepUpper ca@(c : cs)
	| isUpper c = "" : sepUpper (toLower c : cs)
	| otherwise = case sepUpper cs of
		cs : css -> (c : cs) : css
		[] -> error "never occur"
		

takeDefinition :: String -> [String] -> [(String, Name)]
takeDefinition nm = map ((\[t, n] -> (t, makeName $ init n)) . words)
	. takeWhile (not . (== "} " ++ nm ++ ";")) . tail
	. dropWhile (not . (("typedef struct " ++ nm ++ " {") `isPrefixOf`))

makeName :: String -> Name
makeName str = case span (/= '[') str of
	(t, "") -> Atom t
	(t, '[' : n_) -> List t . read $ init n_
	_ -> error "bad list"

listOf :: String -> String
listOf t = "List" ++ (concat . map capitalize $ sep '_' t)

sep :: Eq a => a -> [a] -> [[a]]
sep s xs = case d of [] -> [t]; _ : r -> t : sep s r
	where (t, d) = span (/= s) xs

capitalize :: String -> String
capitalize = \case "" -> ""; c : cs -> toUpper c : map toLower cs

unCapitalize :: String -> String
unCapitalize = \case "" -> ""; c : cs -> toLower c : cs
