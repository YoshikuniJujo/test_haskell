STMとReal-Time Queueで作るマルチスレッドズンドコキヨシ
======================================================

サンプルコード
--------------

### 仕様

* ズンをキューに追加する
	+ 同時に「ズン」を表示
* ドコをキューに追加する
	+ 同時に「ドコ」を表示
* 「ズン」「ズン」「ズン」「ズン」「ドコ」をキューから取り出したら終了
	+ 「キ・ヨ・シ!」と表示する
* 一定時間を過ぎたら終了
	+ 「<タイムアウト>」と表示する

#### 許容される動作

「お遊び」的なコードであり、また、いくつかの技術の使用サンプル的なコードなので、
コードを簡潔にするために、見かたによっては「不具合」とも言えるいくつかの動作を許容する。

* ズンやドコを示すデータがキューから「ズン」「ズン」「ズン」「ズン」「ドコ」の順で取り出されたら終了するが
	+ 必ずしもこの順に表示されるとは限らない
	+ 表示を「デバッグ用のメッセージ」と考えれば、この動作は許容できる
* 終了条件になったとしてもズンスレッドやドコスレッドがすぐに終了するとは限らない
	+ 「ズン」「ズン」「ズン」「ズン」「ドコ」が、この順にキューを通過したことは保証される
	+ その後もいくつかの「ズン」や「ドコ」がキューに追加される可能性はある
	+ 「そのパターンが存在する」ことを検出するという用途と考えれば許容される動作

#### トレードオフ

みっつの要素についてトレードオフがある。

* リアルタイム性
* 正確さ
* コードの簡潔さ

今回は「リアルタイム性」と「コードの簡潔さ」を取った。
別のふたつを取ることもできる。

##### 「正確さ」と「コードの簡潔さ」

「表示」をメインスレッドで行うことで、「正確な表示」を実現できる。
ただし、この場合、最後の「ズン」「ズン」「ズン」「ズン」「ドコ」のところなどが、
リアルタイムに表示されずに「終了判定」の終了後にまとめて表示されることになる。

##### 「リアルタイム性」と「正確さ」

「判定の段階」をあらわす状態を追加することで、「リアルタイム性」と「正確さ」とが実現できる。
ただ、これをやるとコードが複雑になり、「サンプルコード」という点で必要な「わかりやすさ」が犠牲になる。

#### スレッド

4つのスレッドがそれぞれの機能をになう。

* メインスレッド
	+ キューの内容をチェックする
	+ Timeoutが先頭にあれば「<タイムアウト>」と表示して終了する
	+ 「ズン」が4つ続いたあとに「ドコ」があれば「キ・ヨ・シ!」と表示して終了する
* ズンスレッド
	+ ランダムな時間の待ちのあとに「ズン」を表示して、対応するデータをキューの末尾に追加
* ドコスレッド
	+ ランダムな時間の待ちのあとに「ドコ」を表示して、対応するデータをキューの末尾に追加
* タイムアウトスレッド
	+ 適当な時間の待ちのあとにTimeoutをキューの先頭に追加

時間は動かして楽しいように、つぎのように調整した

* ランダムな待ちは100マイクロ秒から100ミリ秒のあいだを100マイクロ秒きざみで選ばれる
* 適当な時間の待ちは5秒

### ソースコード

[try-concurrent-zundoko](https://github.com/YoshikuniJujo/test_haskell/tree/master/tribial/try-concurrent-zundoko)
