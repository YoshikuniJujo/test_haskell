※これは解答用テキストファイルです。

■2桁の整数を「2進数で表した時」と「2進化10進数で表した時」に、
ビット列に含まれる「1」の数が等しいものがいくつあるかを求めてください。未記入の場合は大幅な減点となります。
記入例）
10個

あなたの解答）
20個



■使用言語・動作環境について
(1)言語の種類を記入してください。未記入の場合、減点となります。

Haskell

(2)コンパイラ／インタプリタの名称・バージョン情報を記入してください。未記入の場合、減点となります。

The Glorious Glasgow Haskell Compilation System, version 7.6.3

■プログラムの特長・工夫した点等、アピールポイントについて。
あなたが書いたコードの内容や工夫した点をわかりやすく説明してください。
未記入の場合や「特になし」のような記述は、大幅な減点となります。

問題文の「2桁の整数」は「10進法で表現して2桁の整数」と解釈した。

関数digitsの引数を変化させることで1桁以上の「Int型で表現できる値の範囲内」で
拡張性がある(ただしここでは0は0桁の整数として考えている)。
Integer型を使うかまたはNumクラスのインスタンスとして一般的な表現にすれば
1以上の「任意の桁数」で実行可能だが、あまり現実的でないため、
可読性も考えて今回はInt型を指定した。

整数を10進法の数字の列に分解するほうが素直な解法かと思うが、
逆に数字の列を10進法で整数に合成するほうが処理が簡単なのでそちらの方法を採った。
割る数が2のべき乗でない場合、割算や剰余の計算よりも、掛け算と足し算のほうが、
処理の効率は良さそうだという点も考慮した。

整数への合成やビットへの分解は再帰を使って簡単に行うことができるが、
可読性を高めるために直接的な再帰よりもfoldl'やunfoldrを使用した。

foldlではなくfoldl'を使った理由は空間効率改善のためである。
具体的にはたたみこみを正格評価で行うことで空間効率の最適化となる。
プライム1文字で空間効率が大幅に改善することもある。

数字の列の数え上げ関数digitsについてはリスト内包表記により可読性を高めている。

■もし企業からのスカウトメールがきたらどのくらい積極的にアクションすると思いますか？任意でお答えください。
「積極的に会ってみたいと思う」「社名や条件次第では会ってみたいと思う」「よほどのことがない限り返信しない」、他ありましたら記入してください。

楽しく話ができそうなら会ってみたい。

■あなたが書いたコードを貼り付けてください。未記入の場合は評価できません。

import Data.List
import Data.Bits

digits :: Int -> [[Int]]
digits n = [ d : ds | d <- [1 .. 9], ds <- dgt (n - 1) ]
	where
	dgt k | k < 1 = [[]]
	dgt k = [ d : ds | d <- [0 .. 9], ds <- dgt (k - 1) ]

uncons :: Int -> Maybe (Int, Int)
uncons 0 = Nothing
uncons n = Just (n .&. 1, n `shiftR` 1)

check :: [Int] -> Bool
check ds = sum (concatMap (unfoldr uncons) ds)
	== sum (unfoldr uncons $ foldl' ((+) . (* 10)) 0 ds)

main :: IO ()
main = print . length . filter check $ digits 2
